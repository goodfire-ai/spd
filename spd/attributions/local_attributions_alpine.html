<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Attributions Graph</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #fafafa;
            display: flex;
            height: 100vh;
        }
        /* Sidebar styles */
        .sidebar {
            width: 280px;
            background: #fff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
            background: #f5f5f5;
        }
        .sidebar-header h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; }
        .search-btn {
            width: 100%;
            padding: 0.5rem;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .search-btn:hover { background: #1976d2; }
        .search-btn:disabled { background: #ccc; cursor: not-allowed; }
        .search-info {
            padding: 0.5rem 1rem;
            background: #e3f2fd;
            font-size: 0.8rem;
            color: #1565c0;
        }
        .search-results {
            flex: 1;
            overflow-y: auto;
        }
        .search-result {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.15s;
        }
        .search-result:hover { background: #f5f5f5; }
        .search-result.active { background: #e3f2fd; border-left: 3px solid #2196f3; }
        .search-result-id { font-size: 0.75rem; color: #666; margin-bottom: 0.25rem; }
        .search-result-preview {
            font-family: monospace;
            font-size: 0.8rem;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* Main content */
        .main-content {
            flex: 1;
            padding: 1rem;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }
        h1 { margin-top: 0; font-size: 1.5rem; }
        .controls {
            display: flex;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-wrap: wrap;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .controls input[type="number"] {
            width: 80px;
            padding: 0.25rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .controls select {
            padding: 0.25rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }
        .edge-count { color: #666; font-size: 0.9rem; }
        .db-info { color: #666; font-size: 0.85rem; margin-left: auto; }
        .graph-wrapper {
            display: flex;
            max-height: 70vh;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .layer-labels-container {
            position: sticky;
            left: 0;
            background: white;
            border-right: 1px solid #eee;
            z-index: 11;
            flex-shrink: 0;
        }
        .graph-container {
            overflow: auto;
            flex: 1;
            position: relative;
        }
        .token-labels-container {
            position: sticky;
            bottom: 0;
            background: white;
            border-top: 1px solid #eee;
            z-index: 10;
        }
        svg { display: block; }
        .edge-pos, .edge-neg { display: line-block; width: 30px; height: 3px; margin-right: 0.25rem; vertical-align: middle; }
        .edge-pos { background: #2196f3; }
        .edge-neg { background: #f44336; }
        .legend { color: #666; font-size: 0.85rem; display: flex; align-items: center; gap: 0.75rem; }
        .edge-tooltip {
            position: fixed;
            padding: 0.5rem 0.75rem;
            background: #fff;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1001;
            pointer-events: none;
            font-size: 0.85rem;
        }
        .edge-tooltip-row { margin: 0.2rem 0; }
        .edge-tooltip-label { color: #666; margin-right: 0.5rem; }
        .edge-tooltip code { background: #f5f5f5; padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.8rem; }
        .node-local-section {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }
        .node-local-section h4 { margin: 0 0 0.25rem 0; font-size: 0.8rem; color: #1565c0; }
        .component-section h4 { margin: 0.75rem 0 0.25rem 0; font-size: 0.85rem; color: #333; }
        .loading { padding: 2rem; text-align: center; color: #666; }
        .error-banner {
            padding: 0.75rem 1rem;
            background: #ffebee;
            border: 1px solid #f44336;
            border-radius: 4px;
            color: #c62828;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .error-banner button {
            margin-left: auto;
            padding: 0.25rem 0.5rem;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .error-banner button:hover { background: #d32f2f; }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #e0e0e0;
            border-top-color: #2196f3;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loading-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #666;
        }
        .search-error {
            padding: 0.5rem 1rem;
            background: #ffebee;
            color: #c62828;
            font-size: 0.8rem;
        }
        .node-details {
            position: fixed;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            max-width: 1000px;
            max-height: 800px;
            overflow-y: auto;
            z-index: 1000;
            pointer-events: auto;
        }
        .pinned-container {
            margin-top: 1rem;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .pinned-container h3 {
            margin: 0 0 0.75rem 0;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .pinned-items {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }
        .pinned-item {
            flex-shrink: 0;
            min-width: 350px;
            max-width: 500px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
            background: #fafafa;
        }
        .pinned-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .unpin-btn {
            cursor: pointer;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }
        .edge { transition: opacity 0.15s, stroke-width 0.15s; }
        .edge.highlighted { opacity: 1 !important; stroke-width: 3 !important; }
        .node { transition: stroke-width 0.15s, filter 0.15s; cursor: pointer; }
        .node.same-component {
            stroke: #000 !important;
            stroke-width: 2.5 !important;
            filter: brightness(0.7) saturate(1.5);
            opacity: 1 !important;
        }
        .example-row {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin: 0.5rem 0;
            font-family: monospace;
            font-size: 0.85rem;
        }
        .example-token {
            padding: 2px 4px;
            border-radius: 2px;
        }
        .example-token.active {
            font-weight: bold;
            border: 1px solid #333;
        }
        .pr-table { font-size: 0.85rem; margin-top: 0.5rem; }
        .pr-table th, .pr-table td { padding: 0.25rem 0.5rem; text-align: left; }
        .stats { margin: 0.25rem 0; font-size: 0.85rem; }
        h4 { margin: 0.75rem 0 0.25rem 0; font-size: 0.85rem; }
        .tables-row { display: flex; gap: 2rem; flex-wrap: wrap; }
    </style>
</head>
<body x-data="app()">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h3>Search Prompts</h3>
            <button
                class="search-btn"
                :disabled="pinnedNodes.length === 0 || searchLoading"
                @click="searchPrompts"
            >
                <template x-if="searchLoading">
                    <span class="loading-text"><span class="loading-spinner"></span> Searching...</span>
                </template>
                <template x-if="!searchLoading">
                    <span x-text="pinnedNodes.length === 0 ? 'Pin components to search' : `Find prompts with ${pinnedNodes.length} pinned component${pinnedNodes.length > 1 ? 's' : ''}`"></span>
                </template>
            </button>
        </div>
        <div class="search-error" x-show="searchError" x-text="searchError"></div>
        <div class="search-info" x-show="searchResults.length > 0 && !searchError">
            Found <span x-text="searchResults.length"></span> prompt<span x-show="searchResults.length !== 1">s</span>
        </div>
        <div class="search-results">
            <template x-for="p in searchResults" :key="p.id">
                <div
                    class="search-result"
                    :class="{ active: p.id === currentPromptId }"
                    @click="loadPrompt(p.id)"
                >
                    <div class="search-result-id">Prompt #<span x-text="p.id"></span></div>
                    <div class="search-result-preview" x-text="p.preview"></div>
                </div>
            </template>
        </div>
    </div>

    <!-- Main content -->
    <div class="main-content">
        <h1>Local Attributions Graph</h1>

        <!-- Loading state -->
        <div class="loading" x-show="loading" x-text="loadingMessage"></div>

        <!-- Main app -->
        <div x-show="!loading">
            <!-- Error banner for prompt loading -->
            <div class="error-banner" x-show="promptError">
                <span x-text="promptError"></span>
                <button @click="loadPrompt(currentPromptId)">Retry</button>
            </div>

            <div class="controls">
                <label>
                    Prompt:
                    <select x-model="currentPromptId" @change="loadPrompt(parseInt($event.target.value))">
                        <template x-for="p in allPrompts" :key="p.id">
                            <option :value="p.id" x-text="`${p.id}: ${p.preview}`"></option>
                        </template>
                    </select>
                </label>
                <label>
                    Max mean CI:
                    <input type="number" x-model.number="maxMeanCI" min="0" max="1" step="0.01" @change="reloadWithFilters()">
                </label>
                <label>
                    Top K edges:
                    <input type="number" x-model.number="topK" min="10" max="10000" step="100" @change="render()">
                </label>
                <label>
                    Node layout:
                    <select x-model="nodeLayout" @change="render()">
                        <option value="jittered">Jittered</option>
                        <option value="shuffled">Shuffled</option>
                        <option value="importance">By importance</option>
                    </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.25rem;">
                    <input type="checkbox" x-model="normalizeEdges" @change="reloadWithFilters()">
                    Normalize edges
                </label>
                <label style="display: flex; align-items: center; gap: 0.25rem;">
                    <input type="checkbox" x-model="useOptimized">
                    Optimize CI
                </label>
                <template x-if="useOptimized">
                    <div style="display: flex; gap: 1rem; align-items: center; padding: 0.5rem; background: #e8f5e9; border-radius: 4px;">
                        <label style="display: flex; align-items: center; gap: 0.25rem;">
                            imp_min:
                            <input type="number" x-model.number="impMinCoeff" min="0.001" max="10" step="0.01" style="width: 70px;">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.25rem;">
                            ce:
                            <input type="number" x-model.number="ceLossCoeff" min="0.001" max="10" step="0.1" style="width: 70px;">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.25rem;">
                            steps:
                            <input type="number" x-model.number="optimSteps" min="10" max="5000" step="100" style="width: 70px;">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.25rem;">
                            pnorm:
                            <input type="number" x-model.number="optimPnorm" min="0.1" max="1" step="0.1" style="width: 60px;">
                        </label>
                        <button
                            @click="reloadWithFilters()"
                            :disabled="promptLoading"
                            style="padding: 0.4rem 0.8rem; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;"
                        >
                            Run
                        </button>
                    </div>
                </template>
                <template x-if="optimizationResult">
                    <div style="display: flex; gap: 1rem; align-items: center; padding: 0.5rem 0.75rem; background: #fff3e0; border-radius: 4px; font-size: 0.85rem;">
                        <span>
                            <strong>Target:</strong> "<span x-text="optimizationResult.label_str"></span>"
                            @ <span x-text="(optimizationResult.label_prob * 100).toFixed(1)"></span>%
                        </span>
                        <span>
                            <strong>L0:</strong> <span x-text="optimizationResult.l0_total.toFixed(0)"></span> active
                        </span>
                    </div>
                </template>
                <span class="edge-count">Showing <span x-text="visibleEdgeCount"></span> edges</span>
                <span class="legend">
                    <span class="edge-pos"></span><span x-text="normalizeEdges ? '+1' : '+' + maxAbsAttr.toFixed(2)"></span>
                    <span class="edge-neg"></span><span x-text="normalizeEdges ? '-1' : '-' + maxAbsAttr.toFixed(2)"></span>
                    <span style="opacity: 0.3;">faint</span> → <span style="opacity: 1;">solid</span> = |strength|
                </span>
                <span class="db-info">DB: <span x-text="promptCount"></span> prompts</span>
            </div>

            <div class="graph-wrapper" style="position: relative;">
                <!-- Loading overlay -->
                <div class="loading-overlay" x-show="promptLoading">
                    <span class="loading-text"><span class="loading-spinner"></span> Loading prompt...</span>
                </div>
                <div class="layer-labels-container" x-ref="layerLabels"></div>
                <div class="graph-container">
                    <svg x-ref="graph"></svg>
                    <div class="token-labels-container" x-ref="tokenLabels"></div>
                </div>
            </div>

            <!-- Pinned components -->
            <div class="pinned-container" x-show="pinnedNodes.length > 0">
                <h3>
                    <span>Pinned Components</span>
                    <button @click="pinnedNodes = []" style="font-size: 0.8rem; padding: 0.25rem 0.5rem; cursor: pointer;">Clear all</button>
                </h3>
                <div class="pinned-items">
                    <template x-for="pinned in pinnedNodes" :key="`${pinned.layer}:${pinned.cIdx}`">
                        <div class="pinned-item">
                            <div class="pinned-item-header">
                                <strong x-text="`${pinned.layer}:${pinned.cIdx}`"></strong>
                                <button class="unpin-btn" @click="unpinNode(pinned.layer, pinned.cIdx)">✕ unpin</button>
                            </div>
                            <template x-if="pinned.layer === 'output' || activationContextsSummary">
                                <div x-html="buildComponentHtmlNoSeq(pinned.layer, pinned.cIdx)"></div>
                            </template>
                            <template x-if="pinned.layer !== 'output' && !activationContextsSummary && activationContextsLoading">
                                <div class="loading-text"><span class="loading-spinner"></span> Loading details...</div>
                            </template>
                            <template x-if="pinned.layer !== 'output' && !activationContextsSummary && !activationContextsLoading && activationContextsError">
                                <div style="color: #c62828; font-size: 0.85rem;" x-text="activationContextsError"></div>
                            </template>
                            <template x-if="pinned.layer !== 'output' && !activationContextsSummary && !activationContextsLoading && !activationContextsError">
                                <div style="color: #666; font-size: 0.85rem;">No component details available</div>
                            </template>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Hover tooltip -->
            <div
                class="node-details"
                x-show="hoveredNode && !isNodePinned(hoveredNode.layer, hoveredNode.cIdx)"
                :style="`left: ${tooltipPos.x}px; top: ${tooltipPos.y}px`"
                @mouseenter="isHoveringTooltip = true"
                @mouseleave="isHoveringTooltip = false; maybeHideTooltip()"
            >
                <!-- Local section first (for non-output nodes) -->
                <template x-if="hoveredNode && hoveredNode.layer !== 'output'">
                    <div x-html="buildLocalSectionHtml(hoveredNode.layer, hoveredNode.seqIdx, hoveredNode.cIdx)"></div>
                </template>

                <h3>Component Details</h3>

                <template x-if="hoveredNode && hoveredNode.layer === 'output'">
                    <div x-html="buildComponentHtml(hoveredNode.layer, hoveredNode.seqIdx, hoveredNode.cIdx)"></div>
                </template>
                <template x-if="hoveredNode && hoveredNode.layer !== 'output' && !activationContextsSummary && activationContextsLoading">
                    <p class="loading-text"><span class="loading-spinner"></span> Loading component details...</p>
                </template>
                <template x-if="hoveredNode && hoveredNode.layer !== 'output' && !activationContextsSummary && !activationContextsLoading && activationContextsError">
                    <p style="color: #c62828;" x-text="activationContextsError"></p>
                </template>
                <template x-if="hoveredNode && hoveredNode.layer !== 'output' && !activationContextsSummary && !activationContextsLoading && !activationContextsError">
                    <p style="color: #666;">No component details available</p>
                </template>
                <template x-if="hoveredNode && hoveredNode.layer !== 'output' && activationContextsSummary">
                    <div x-html="buildComponentHtml(hoveredNode.layer, hoveredNode.seqIdx, hoveredNode.cIdx)"></div>
                </template>
            </div>

            <!-- Edge hover tooltip -->
            <div
                class="edge-tooltip"
                x-show="hoveredEdge"
                :style="`left: ${edgeTooltipPos.x}px; top: ${edgeTooltipPos.y}px`"
            >
                <template x-if="hoveredEdge">
                    <div>
                        <div class="edge-tooltip-row">
                            <span class="edge-tooltip-label">From:</span>
                            <code x-text="hoveredEdge.src"></code>
                        </div>
                        <div class="edge-tooltip-row">
                            <span class="edge-tooltip-label">To:</span>
                            <code x-text="hoveredEdge.tgt"></code>
                        </div>
                        <div class="edge-tooltip-row">
                            <span class="edge-tooltip-label">Strength:</span>
                            <span :style="`color: ${hoveredEdge.val > 0 ? '#2196f3' : '#f44336'}; font-weight: bold;`" x-text="hoveredEdge.val.toFixed(4)"></span>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </div>

    <script>
        const COMPONENT_SIZE = 8;
        const COMPONENT_GAP = 2;
        const LAYER_GAP = 30;
        const MARGIN = { top: 60, right: 40, bottom: 20, left: 20 };
        const LABEL_WIDTH = 100;
        // Row order for layout (qkv share a row)
        const ROW_ORDER = ['wte', 'qkv', 'o_proj', 'c_fc', 'down_proj', 'output'];
        // Within qkv row, order is q, k, v
        const QKV_SUBTYPES = ['q_proj', 'k_proj', 'v_proj'];
        const NODE_COLOR = "#333";

        // Simple timing utility that avoids duplicate timer warnings
        const timers = {};
        function timeStart(label) {
            timers[label] = performance.now();
        }
        function timeEnd(label) {
            if (timers[label]) {
                const duration = performance.now() - timers[label];
                console.log(`[timing] ${label}: ${duration.toFixed(1)}ms`);
                delete timers[label];
            }
        }

        function app() {
            return {
                // Constants
                NODE_COLOR,

                // API
                apiBase: window.location.origin || 'http://localhost:8765',

                // Loading state
                loading: true,
                loadingMessage: 'Loading data...',

                // Per-operation loading/error states
                promptLoading: false,
                promptError: null,
                searchLoading: false,
                searchError: null,
                activationContextsError: null,

                // Data
                promptCount: 0,
                allPrompts: [],
                currentPromptId: null,
                /**
                 * {
                 *   "id": number,
                 *   "tokens": string[],
                 *   "edges": { src: "layer:seq:cIdx", tgt: "layer:seq:cIdx", val: float }[],
                 *   "outputProbs": { "seq:cIdx": { prob: float, token: string } },
                 * }
                 */
                promptData: null,
                activationContextsSummary: null,  // Just {subcomponent_idx, mean_ci} per component
                componentDetailsCache: {},  // layer:idx -> full component data (lazy-loaded)
                componentDetailsLoading: {},  // layer:idx -> true if currently loading
                activationContextsLoading: false,

                // Computed from prompt data
                allEdges: [],
                componentImportance: {},
                componentImportanceLocal: {},
                maxAbsAttr: 1,
                maxImportanceLocal: 1,

                // UI state
                maxMeanCI: 1.0,  // No CI filtering by default
                topK: 800,
                normalizeEdges: true,  // Normalize incoming edges to each node
                nodeLayout: 'importance',  // 'importance' | 'shuffled' | 'jittered'
                visibleEdgeCount: 0,

                // Optimization controls
                useOptimized: false,
                impMinCoeff: 0.1,
                ceLossCoeff: 1.0,
                optimSteps: 500,
                optimLr: 0.01,
                optimPnorm: 0.3,
                optimizationResult: null,  // Stats from optimization endpoint
                pinnedNodes: [],
                hoveredNode: null,
                hoveredEdge: null,
                isHoveringTooltip: false,
                tooltipPos: { x: 0, y: 0 },
                edgeTooltipPos: { x: 0, y: 0 },
                searchResults: [],

                // Layout cache
                layerYPositions: {},
                nodePositions: {},

                // Event delegation bound flag
                svgListenersBound: false,

                async init() {
                    timeStart('init.total');
                    try {
                        timeStart('init.fetchMeta');
                        const metaResponse = await fetch(`${this.apiBase}/api/meta`);
                        if (!metaResponse.ok) {
                            throw new Error(`Server error: ${metaResponse.status} ${metaResponse.statusText}`);
                        }
                        const meta = await metaResponse.json();
                        timeEnd('init.fetchMeta');
                        this.promptCount = meta.prompt_count;

                        if (meta.prompt_count > 0) {
                            // Load first prompt immediately
                            // await this.loadPrompt(1);

                            // Load prompts list in background
                            timeStart('init.fetchPromptsList');
                            const promptsResponse = await fetch(`${this.apiBase}/api/prompts`)
                                // .then(r => {
                            if (!promptsResponse.ok) throw new Error(`Server error: ${promptsResponse.status}`);
                            this.allPrompts = await promptsResponse.json();
                            timeEnd('init.fetchPromptsList');

                            await this.loadPrompt(1);

                            // Load activation contexts in background
                            this.loadActivationContexts();
                        } else {
                            this.loadingMessage = 'No prompts in database';
                        }
                    } catch (e) {
                        this.loadingMessage = `Error connecting to server: ${e.message}. Make sure the server is running.`;
                        console.error(e);
                    }
                    timeEnd('init.total');
                },

                async loadPrompt(promptId) {
                    if (this.promptLoading) {
                        console.warn('Already loading a prompt, ignoring request');
                        return;
                    }

                    timeStart('loadPrompt.total');
                    this.currentPromptId = promptId;
                    this.promptLoading = true;
                    this.promptError = null;

                    try {
                        // Fetch with server-side filtering
                        const params = new URLSearchParams({
                            max_mean_ci: this.maxMeanCI,
                            normalize: this.normalizeEdges,
                        });

                        // Add optimization params if using optimized endpoint
                        let endpoint = `/api/prompt/${promptId}`;
                        if (this.useOptimized) {
                            endpoint = `/api/prompt/${promptId}/optimized`;
                            params.set('imp_min_coeff', this.impMinCoeff);
                            params.set('ce_loss_coeff', this.ceLossCoeff);
                            params.set('steps', this.optimSteps);
                            params.set('lr', this.optimLr);
                            params.set('pnorm', this.optimPnorm);
                        }

                        timeStart('loadPrompt.fetch');
                        const response = await fetch(`${this.apiBase}${endpoint}?${params}`);
                        if (!response.ok) {
                            throw new Error(`Server error: ${response.status} ${response.statusText}`);
                        }
                        const promptData = await response.json();
                        timeEnd('loadPrompt.fetch');

                        if (promptData.error) {
                            throw new Error(promptData.error);
                        }

                        // {
                        //     "id": number,
                        //     "tokens": string[],
                        //     "edges": { src: "layer:seq:cIdx", tgt: "layer:seq:cIdx", val: float }[],
                        //     "outputProbs": { "seq:cIdx": { prob: float, token: string } },
                        // }
                        this.promptData = promptData;

                        // Store optimization results if present
                        this.optimizationResult = promptData.optimization || null;

                        this.allEdges = promptData.edges.map(edge => ({
                            srcKey: edge.src,
                            tgtKey: edge.tgt,
                            val: edge.val,
                        }));

                        // Find max attribution
                        this.maxAbsAttr = 1
                        for (const edge of this.allEdges) {
                            const absVal = Math.abs(edge.val);
                            if (absVal > this.maxAbsAttr) {
                                this.maxAbsAttr = absVal;
                            }
                        }

                        // Build importance maps from edges
                        this.componentImportance = {};
                        this.componentImportanceLocal = {};
                        for (const edge of this.allEdges) {
                            const valSq = edge.val * edge.val;

                            // Parse keys to get global component key (layer:cIdx without seq)
                            const [srcLayer, , srcCIdx] = edge.srcKey.split(':');
                            const [tgtLayer, , tgtCIdx] = edge.tgtKey.split(':');
                            const srcGlobalKey = `${srcLayer}:${srcCIdx}`;
                            const tgtGlobalKey = `${tgtLayer}:${tgtCIdx}`;

                            this.componentImportance[srcGlobalKey] = (this.componentImportance[srcGlobalKey] || 0) + valSq;
                            this.componentImportance[tgtGlobalKey] = (this.componentImportance[tgtGlobalKey] || 0) + valSq;
                            this.componentImportanceLocal[edge.srcKey] = (this.componentImportanceLocal[edge.srcKey] || 0) + valSq;
                            this.componentImportanceLocal[edge.tgtKey] = (this.componentImportanceLocal[edge.tgtKey] || 0) + valSq;
                        }

                        this.maxImportanceLocal = 1;
                        for (const imp of Object.values(this.componentImportanceLocal)) {
                            if (imp > this.maxImportanceLocal) {
                                this.maxImportanceLocal = imp;
                            }
                        }

                        this.loading = false;
                        this.$nextTick(() => {
                            timeStart('loadPrompt.render');
                            this.render();
                            timeEnd('loadPrompt.render');
                            timeEnd('loadPrompt.total');
                        });
                    } catch (e) {
                        console.error('Error loading prompt:', e);
                        this.promptError = `Failed to load prompt: ${e.message}`;
                        this.loading = false;
                        timeEnd('loadPrompt.total');
                    } finally {
                        this.promptLoading = false;
                    }
                },

                async reloadWithFilters() {
                    // Re-fetch current prompt with new filter params
                    if (!this.currentPromptId) {
                        throw new Error('No prompt ID to reload');
                    }
                    await this.loadPrompt(this.currentPromptId);
                },

                async loadActivationContexts() {
                    // Load lightweight summary (just idx + mean_ci per component)
                    if (this.activationContextsSummary || this.activationContextsLoading) return;
                    this.activationContextsLoading = true;
                    this.activationContextsError = null;

                    timeStart('loadActCtx.fetch');
                    try {
                        const response = await fetch(`${this.apiBase}/api/activation_contexts/summary`);
                        if (!response.ok) {
                            throw new Error(`Server error: ${response.status} ${response.statusText}`);
                        }
                        const data = await response.json();
                        if (data.error) {
                            throw new Error(data.error);
                        }
                        this.activationContextsSummary = data;
                        timeEnd('loadActCtx.fetch');
                    } catch (e) {
                        console.error('Error loading activation contexts:', e);
                        this.activationContextsError = `Failed to load component details: ${e.message}`;
                        timeEnd('loadActCtx.fetch');
                    } finally {
                        this.activationContextsLoading = false;
                    }
                },

                async loadComponentDetail(layer, cIdx) {
                    // Lazy-load full component details on hover/pin
                    const cacheKey = `${layer}:${cIdx}`;
                    if (this.componentDetailsCache[cacheKey] || this.componentDetailsLoading[cacheKey]) return;

                    this.componentDetailsLoading[cacheKey] = true;
                    try {
                        const response = await fetch(`${this.apiBase}/api/activation_contexts/${encodeURIComponent(layer)}/${cIdx}`);
                        if (!response.ok) {
                            throw new Error(`Server error: ${response.status}`);
                        }
                        const data = await response.json();
                        if (data.error) {
                            console.warn(`Component detail error: ${data.error}`);
                            return;
                        }
                        this.componentDetailsCache[cacheKey] = data;
                    } catch (e) {
                        console.error(`Error loading component detail for ${cacheKey}:`, e);
                    } finally {
                        this.componentDetailsLoading[cacheKey] = false;
                    }
                },

                getComponentDetail(layer, cIdx) {
                    // Get cached component detail, or trigger load if not available
                    const cacheKey = `${layer}:${cIdx}`;
                    if (this.componentDetailsCache[cacheKey]) {
                        return this.componentDetailsCache[cacheKey];
                    }
                    // Trigger async load (will cause re-render when complete)
                    this.loadComponentDetail(layer, cIdx);
                    return null;
                },

                parseLayer(name) {
                    // Handle special layers: wte (input embeddings) and output (logits)
                    if (name === 'wte') {
                        return { name, block: -1, type: 'embed', subtype: 'wte' };
                    }
                    if (name === 'output') {
                        return { name, block: Infinity, type: 'output', subtype: 'output' };
                    }
                    const m = name.match(/h\.(\d+)\.(attn|mlp)\.(\w+)/);
                    if (!m) throw new Error(`parseLayer: unrecognized layer name: ${name}`);
                    return { name, block: +m[1], type: m[2], subtype: m[3] };
                },

                getRowKey(layer) {
                    // Returns the row key for layout purposes
                    // q_proj, k_proj, v_proj all map to 'qkv' row
                    const info = this.parseLayer(layer);
                    if (QKV_SUBTYPES.includes(info.subtype)) {
                        return `h.${info.block}.qkv`;
                    }
                    return layer;
                },

                getFilteredEdgesAndNodes() {
                    // Server already filtered by max_mean_ci
                    // Build the active nodes set from edges

                    // topK
                    const sortedEdges = [...this.allEdges].sort((a, b) => Math.abs(b.val) - Math.abs(a.val));
                    const filteredEdges = sortedEdges.slice(0, this.topK);

                    const activeNodes = new Set();
                    for (const edge of filteredEdges) {
                        activeNodes.add(edge.srcKey);
                        activeNodes.add(edge.tgtKey);
                    }

                    // For output nodes: include all tokens with prob >= min prob of kept tokens
                    // This ensures we don't show low-prob tokens while hiding higher-prob ones
                    const outputNodesWithEdges = new Set();
                    for (const nodeKey of activeNodes) {
                        if (nodeKey.startsWith('output:')) {
                            outputNodesWithEdges.add(nodeKey);
                        }
                    }

                    if (outputNodesWithEdges.size > 0) {
                        // Find min probability among output nodes that have edges
                        let minProb = Infinity;
                        for (const nodeKey of outputNodesWithEdges) {
                            const [, seqIdx, cIdx] = nodeKey.split(':');
                            const probKey = `${seqIdx}:${cIdx}`;
                            const entry = this.promptData.outputProbs[probKey];
                            if (entry === undefined) {
                                const nodeEdges = this.allEdges.filter(e => e.tgtKey === nodeKey);
                                throw new Error(`Output node ${nodeKey} has edge but no entry in outputProbs: ${nodeEdges.slice(0, 30)}`)
                            }
                            if (entry.prob < minProb) {
                                minProb = entry.prob;
                            }
                        }

                        // Add all output nodes with prob >= minProb
                        for (const [probKey, entry] of Object.entries(this.promptData.outputProbs)) {
                            if (entry.prob >= minProb) {
                                const [seqIdx, cIdx] = probKey.split(':');
                                activeNodes.add(`output:${seqIdx}:${cIdx}`);
                            }
                        }
                    }

                    return { edges: filteredEdges, activeNodes };
                },

                buildLayout(activeNodes) {
                    const nodesPerLayerSeq = {};
                    const allLayers = new Set();
                    const allRows = new Set();

                    for (const nodeKey of activeNodes) {
                        const [layer, seqIdx, cIdx] = nodeKey.split(':');
                        allLayers.add(layer);
                        allRows.add(this.getRowKey(layer));
                        const key = `${layer}:${seqIdx}`;
                        if (!nodesPerLayerSeq[key]) nodesPerLayerSeq[key] = [];
                        nodesPerLayerSeq[key].push(+cIdx);
                    }

                    // Sort rows (not individual layers) for Y positioning
                    const parseRow = (r) => {
                        if (r === 'wte') return { block: -1, subtype: 'wte' };
                        if (r === 'output') return { block: Infinity, subtype: 'output' };
                        // qkv rows: h.0.qkv
                        const mQkv = r.match(/h\.(\d+)\.qkv/); if (mQkv) return { block: +mQkv[1], subtype: 'qkv' };
                        // Regular rows: h.0.attn.o_proj or h.0.mlp.c_fc
                        const m = r.match(/h\.(\d+)\.(attn|mlp)\.(\w+)/);
                        if (!m) throw new Error(`parseRow: unrecognized row key: ${r}`);
                        return { block: +m[1], subtype: m[3] };
                    };

                    const rows = Array.from(allRows).sort((a, b) => {
                        const infoA = parseRow(a);
                        const infoB = parseRow(b);
                        if (infoA.block !== infoB.block) return infoA.block - infoB.block;
                        const idxA = ROW_ORDER.indexOf(infoA.subtype);
                        const idxB = ROW_ORDER.indexOf(infoB.subtype);
                        if (idxA === -1) throw new Error(`Unknown subtype in ROW_ORDER: ${infoA.subtype}`);
                        if (idxB === -1) throw new Error(`Unknown subtype in ROW_ORDER: ${infoB.subtype}`);
                        return idxA - idxB;
                    });

                    // Assign Y positions to rows (q,k,v share same Y)
                    const rowYPositions = {};
                    let currentY = MARGIN.top;
                    for (const row of rows.slice().reverse()) {
                        rowYPositions[row] = currentY;
                        currentY += COMPONENT_SIZE + LAYER_GAP;
                    }

                    // Map each layer to its row's Y position
                    this.layerYPositions = {};
                    for (const layer of allLayers) {
                        const rowKey = this.getRowKey(layer);
                        this.layerYPositions[layer] = rowYPositions[rowKey];
                    }

                    const tokens = this.promptData.tokens;

                    // Calculate column widths - for qkv rows, need space for all 3 subtypes
                    const maxComponentsPerSeq = tokens.map((_, seqIdx) => {
                        let maxAtSeq = 0;
                        for (const row of rows) {
                            if (row.endsWith('.qkv')) {
                                const block = row.match(/h\.(\d+)/)[1];
                                let totalQkv = 0;
                                for (const subtype of QKV_SUBTYPES) {
                                    const layer = `h.${block}.attn.${subtype}`;
                                    const nodes = nodesPerLayerSeq[`${layer}:${seqIdx}`] ?? [];
                                    totalQkv += nodes.length;
                                }
                                totalQkv += 2; // gaps between groups
                                maxAtSeq = Math.max(maxAtSeq, totalQkv);
                            } else {
                                for (const layer of allLayers) {
                                    if (this.getRowKey(layer) === row) {
                                        const nodes = nodesPerLayerSeq[`${layer}:${seqIdx}`] ?? [];
                                        maxAtSeq = Math.max(maxAtSeq, nodes.length);
                                    }
                                }
                            }
                        }
                        return maxAtSeq;
                    });

                    const MIN_COL_WIDTH = 30, COL_PADDING = 16;
                    const seqWidths = maxComponentsPerSeq.map(n =>
                        Math.max(MIN_COL_WIDTH, n * (COMPONENT_SIZE + COMPONENT_GAP) + COL_PADDING * 2)
                    );
                    const seqXStarts = [MARGIN.left];
                    for (let i = 0; i < seqWidths.length - 1; i++) {
                        seqXStarts.push(seqXStarts[i] + seqWidths[i]);
                    }

                    this.nodePositions = {};
                    const QkV_GROUP_GAP = COMPONENT_SIZE + COMPONENT_GAP;

                    for (const layer of allLayers) {
                        const info = this.parseLayer(layer);
                        const isQkv = info && QKV_SUBTYPES.includes(info.subtype);
                        const isOutput = layer === 'output';

                        for (let seqIdx = 0; seqIdx < tokens.length; seqIdx++) {
                            const nodes = nodesPerLayerSeq[`${layer}:${seqIdx}`];
                            if (nodes === undefined) continue;

                            let baseX = seqXStarts[seqIdx] + COL_PADDING;
                            const baseY = this.layerYPositions[layer];

                            // For qkv layers, offset X based on which subtype (k, v, q order)
                            if (isQkv) {
                                const block = info.block;
                                const subtypeIdx = QKV_SUBTYPES.indexOf(info.subtype);
                                for (let i = 0; i < subtypeIdx; i++) {
                                    const prevLayer = `h.${block}.attn.${QKV_SUBTYPES[i]}`;
                                    const prevLayerNodes = nodesPerLayerSeq[`${prevLayer}:${seqIdx}`]
                                    const prevCount = prevLayerNodes?.length ?? 0;
                                    baseX += prevCount * (COMPONENT_SIZE + COMPONENT_GAP);
                                    baseX += QkV_GROUP_GAP;
                                }
                            }

                            // Use full column width (minus padding) so jitter spreads across entire seq position
                            const cellWidth = seqWidths[seqIdx] - COL_PADDING * 2;
                            const offsets = this.getComponentOffsetsForLayout(
                                nodes, layer, seqIdx, isOutput, cellWidth
                            );

                            for (let i = 0; i < nodes.length; i++) {
                                const cIdx = nodes[i];
                                this.nodePositions[`${layer}:${seqIdx}:${cIdx}`] = {
                                    x: baseX + offsets[cIdx] + COMPONENT_SIZE / 2,
                                    y: baseY + COMPONENT_SIZE / 2
                                };
                            }
                        }
                    }

                    return { rows, seqWidths, seqXStarts };
                },

                // Get x offsets for each component within a cell based on layout strategy
                // Returns: { [cIdx]: xOffset } where xOffset is relative to cell start
                getComponentOffsetsForLayout(components, layer, seqIdx, isOutput, cellWidth) {
                    const n = components.length;
                    const offsets = {};

                    if (this.nodeLayout === 'importance') {
                        // Sort by importance/probability, place evenly
                        const sorted = [...components].sort((a, b) => {
                            if (isOutput) {
                                const entryA = this.promptData.outputProbs[`${seqIdx}:${a}`];
                                const entryB = this.promptData.outputProbs[`${seqIdx}:${b}`];
                                if (entryA === undefined) throw new Error(`Missing entry for output node ${seqIdx}:${a}`);
                                if (entryB === undefined) throw new Error(`Missing entry for output node ${seqIdx}:${b}`);
                                return entryB.prob - entryA.prob;
                            }
                            const impA = this.componentImportanceLocal[`${layer}:${seqIdx}:${a}`];
                            const impB = this.componentImportanceLocal[`${layer}:${seqIdx}:${b}`];
                            return impB - impA;
                        });
                        for (let i = 0; i < n; i++) {
                            offsets[sorted[i]] = i * (COMPONENT_SIZE + COMPONENT_GAP);
                        }
                        return offsets;
                    }

                    // 'shuffled': deterministic shuffle, then place evenly
                    if (this.nodeLayout === 'shuffled') {
                        const seed = this.hashString(`${layer}:${seqIdx}`);
                        const shuffled = this.seededShuffle([...components], seed);
                        for (let i = 0; i < n; i++) {
                            offsets[shuffled[i]] = i * (COMPONENT_SIZE + COMPONENT_GAP);
                        }
                        return offsets;
                    }

                    if (this.nodeLayout === 'jittered') {
                        // 'jittered': shuffle -> space-around justify -> jitter scaled by 1/n_nodes
                        const seed = this.hashString(`${layer}:${seqIdx}`);
                        const shuffled = this.seededShuffle([...components], seed);

                        // Create seeded random for jitter
                        let jitterSeed = seed;
                        const jitterRandom = () => {
                            jitterSeed |= 0; jitterSeed = jitterSeed + 0x6D2B79F5 | 0;
                            let t = Math.imul(jitterSeed ^ jitterSeed >>> 15, 1 | jitterSeed);
                            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                            return ((t ^ t >>> 14) >>> 0) / 4294967296;
                        };

                        // Space-around: equal space before first, between each, and after last
                        // totalSpace = cellWidth - n * COMPONENT_SIZE
                        // each gap = totalSpace / (n + 1)
                        const totalSpace = cellWidth - n * COMPONENT_SIZE;
                        const gap = totalSpace / (n + 1);

                        // Jitter scales inversely with number of nodes
                        const maxJitter = gap / 2;

                        for (let i = 0; i < n; i++) {
                            // Space-around position: gap + i * (COMPONENT_SIZE + gap)
                            const baseOffset = gap + i * (COMPONENT_SIZE + gap);
                            // Jitter: random value in [-maxJitter, +maxJitter], clamped to cell bounds
                            const jitter = (jitterRandom() - 0.5) * 2 * maxJitter;
                            const jitteredOffset = Math.max(0, Math.min(cellWidth - COMPONENT_SIZE, baseOffset + jitter));
                            offsets[shuffled[i]] = jitteredOffset;
                        }
                        return offsets;
                    }

                    throw new Error(`Unknown node layout: ${this.nodeLayout}`);
                },

                // Simple string hash for deterministic seeding
                hashString(str) {
                    let hash = 0;
                    for (let i = 0; i < str.length; i++) {
                        const char = str.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash;
                    }
                    return Math.abs(hash);
                },

                // Fisher-Yates shuffle with seeded PRNG
                seededShuffle(arr, seed) {
                    // Simple mulberry32 PRNG
                    const random = () => {
                        seed |= 0; seed = seed + 0x6D2B79F5 | 0;
                        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                        return ((t ^ t >>> 14) >>> 0) / 4294967296;
                    };

                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    return arr;
                },

                linearInterpolate(min, max, x) {
                    return min + (max - min) * x;
                },

                render() {
                    if (!this.promptData) {
                        console.error('No prompt data available');
                        return;
                    }
                    console.log('rendering')

                    timeStart('render.filter');
                    const { edges, activeNodes } = this.getFilteredEdgesAndNodes();
                    timeEnd('render.filter');
                    this.visibleEdgeCount = edges.length;

                    timeStart('render.layout');
                    const { rows, seqWidths, seqXStarts } = this.buildLayout(activeNodes);
                    timeEnd('render.layout');
                    const tokens = this.promptData.tokens;

                    const totalSeqWidth = seqXStarts[seqXStarts.length - 1] + seqWidths[seqWidths.length - 1];
                    const width = totalSeqWidth + MARGIN.right;
                    const maxY = Math.max(...Object.values(this.layerYPositions), 0) + COMPONENT_SIZE;
                    const height = maxY + MARGIN.bottom;

                    // Render main graph
                    const svg = this.$refs.graph;
                    svg.setAttribute('width', width);
                    svg.setAttribute('height', height);

                    timeStart('render.buildHtml');
                    // Use groups to ensure nodes are always rendered on top of edges
                    let edgesHtml = '';
                    let nodesHtml = '';

                    for (const e of edges) {
                        const p1 = this.nodePositions[e.srcKey];
                        const p2 = this.nodePositions[e.tgtKey];
                        if (p1 && p2) {
                            const color = e.val > 0 ? '#2196f3' : '#f44336';
                            const w = this.linearInterpolate(1, 4, Math.abs(e.val) / this.maxAbsAttr);
                            const op = this.linearInterpolate(0, 0.5, Math.abs(e.val) / this.maxAbsAttr);
                            // Cubic bezier with vertical tangents at endpoints
                            const dy = Math.abs(p2.y - p1.y);
                            const curveOffset = Math.max(20, dy * 0.4);
                            const cp1y = p1.y - curveOffset;
                            const cp2y = p2.y + curveOffset;
                            const d = `M ${p1.x},${p1.y} C ${p1.x},${cp1y} ${p2.x},${cp2y} ${p2.x},${p2.y}`;
                            edgesHtml += `<path class="edge" data-src="${e.srcKey}" data-tgt="${e.tgtKey}" data-val="${e.val}" d="${d}" stroke="${color}" stroke-width="${w}" opacity="${op}" fill="none"/>`;
                        }
                    }

                    for (const key in this.nodePositions) {
                        const pos = this.nodePositions[key];
                        const [layer, seqIdx, cIdx] = key.split(':');
                        const importance = this.componentImportanceLocal[key] || 0;
                        const intensity = Math.min(1, importance / this.maxImportanceLocal);

                        let fillColor;
                        let opacity;
                        if (layer === 'output') {
                            // Color output nodes by probability (green gradient)
                            const probEntry = this.promptData.outputProbs[`${seqIdx}:${cIdx}`];
                            if (!probEntry) throw new Error(`Missing outputProbs for ${seqIdx}:${cIdx}`);
                            const prob = probEntry.prob;
                            const saturation = 20 + prob * 60;
                            const lightness = 70 - prob * 35;
                            fillColor = `hsl(120, ${saturation}%, ${lightness}%)`;
                            opacity = 0.4 + prob * 0.6;
                        } else {
                            fillColor = NODE_COLOR;
                            opacity = 0.2 + intensity * 0.8;
                        }

                        nodesHtml += `<rect class="node" data-layer="${layer}" data-seq="${seqIdx}" data-cidx="${cIdx}" x="${pos.x - COMPONENT_SIZE/2}" y="${pos.y - COMPONENT_SIZE/2}" width="${COMPONENT_SIZE}" height="${COMPONENT_SIZE}" fill="${fillColor}" rx="1" opacity="${opacity}"/>`;
                    }

                    // Edges first (back), then nodes (front)
                    const html = `<g class="edges-layer">${edgesHtml}</g><g class="nodes-layer">${nodesHtml}</g>`;
                    timeEnd('render.buildHtml');

                    timeStart('render.svgInnerHTML');
                    svg.innerHTML = html;
                    timeEnd('render.svgInnerHTML');

                    // Token labels
                    timeStart('render.tokenLabels');
                    let tokenHtml = `<svg width="${width}" height="50" style="display:block;">`;
                    for (let i = 0; i < tokens.length; i++) {
                        const colCenter = seqXStarts[i] + seqWidths[i] / 2;
                        tokenHtml += `<text x="${colCenter}" y="20" text-anchor="middle" font-size="12" font-family="monospace" font-weight="500">${this.escapeHtml(tokens[i])}</text>`;
                        tokenHtml += `<text x="${colCenter}" y="38" text-anchor="middle" font-size="10" fill="#999">[${i}]</text>`;
                    }
                    tokenHtml += '</svg>';
                    this.$refs.tokenLabels.innerHTML = tokenHtml;
                    timeEnd('render.tokenLabels');

                    // Layer labels - use unique Y positions (rows, not individual layers)
                    timeStart('render.layerLabels');
                    const rowYSet = new Map();
                    for (const layer in this.layerYPositions) {
                        const y = this.layerYPositions[layer];
                        const rowKey = this.getRowKey(layer);
                        if (!rowYSet.has(y)) {
                            rowYSet.set(y, rowKey);
                        }
                    }

                    let layerHtml = `<svg width="${LABEL_WIDTH}" height="${height}" style="display:block;">`;
                    for (const [y, rowKey] of rowYSet) {
                        const yCenter = y + COMPONENT_SIZE / 2;
                        let label;
                        if (rowKey.endsWith('.qkv')) {
                            const blockIdx = rowKey.split('.')[1];
                            label = `${blockIdx}.q/k/v`;
                        } else if (rowKey === 'wte' || rowKey === 'output') {
                            label = rowKey;
                        } else {
                            const m = rowKey.match(/h\.(\d+)\.(attn|mlp)\.(\w+)/);
                            if (!m) throw new Error(`Layer label: unrecognized rowKey format: ${rowKey}`);
                            label = `${m[1]}.${m[3]}`;
                        }
                        layerHtml += `<text x="${LABEL_WIDTH - 10}" y="${yCenter}" text-anchor="end" dominant-baseline="middle" font-size="11" font-weight="500" fill="${NODE_COLOR}">${label}</text>`;
                    }
                    layerHtml += '</svg>';
                    this.$refs.layerLabels.innerHTML = layerHtml;
                    timeEnd('render.layerLabels');

                    // Bind event delegation (only once)
                    this.bindSvgEventDelegation();

                    timeStart('render.highlights');
                    this.updateHighlights();
                    timeEnd('render.highlights');
                },

                bindSvgEventDelegation() {
                    if (this.svgListenersBound) return;
                    this.svgListenersBound = true;

                    const svg = this.$refs.graph;

                    // Event delegation for mouse events on nodes and edges
                    svg.addEventListener('mouseover', (e) => {
                        // Check for edge hover
                        const edge = e.target.closest('.edge');
                        if (edge) {
                            const src = edge.getAttribute('data-src');
                            const tgt = edge.getAttribute('data-tgt');
                            const val = parseFloat(edge.getAttribute('data-val'));
                            this.hoveredEdge = { src, tgt, val };
                            this.edgeTooltipPos = { x: e.clientX + 10, y: e.clientY + 10 };
                            return;
                        }

                        // Check for node hover
                        const node = e.target.closest('.node');
                        if (!node) return;

                        const layer = node.getAttribute('data-layer');
                        const seqIdx = parseInt(node.getAttribute('data-seq'));
                        const cIdx = parseInt(node.getAttribute('data-cidx'));
                        this.hoveredNode = { layer, seqIdx, cIdx };
                        this.tooltipPos = this.calcTooltipPos(e.clientX, e.clientY);
                        this.updateHighlights();
                        // Only load activation contexts for non-output nodes
                        if (layer !== 'output' && !this.activationContextsSummary) this.loadActivationContexts();
                    });

                    svg.addEventListener('mouseout', (e) => {
                        // Check for edge mouseout
                        const edge = e.target.closest('.edge');
                        if (edge) {
                            this.hoveredEdge = null;
                            return;
                        }

                        // Check for node mouseout
                        const node = e.target.closest('.node');
                        if (!node) return;
                        // Check if we're moving to another node or leaving entirely
                        const related = e.relatedTarget?.closest?.('.node');
                        if (!related) {
                            this.maybeHideTooltip();
                        }
                    });

                    svg.addEventListener('click', (e) => {
                        const node = e.target.closest('.node');
                        if (!node) return;

                        timeStart('click.togglePin');
                        const layer = node.getAttribute('data-layer');
                        const cIdx = parseInt(node.getAttribute('data-cidx'));
                        this.togglePin(layer, cIdx);
                        timeEnd('click.togglePin');
                    });
                },

                calcTooltipPos(mouseX, mouseY) {
                    const padding = 15;
                    let left = mouseX + padding;
                    let top = mouseY + padding;
                    if (left + 500 > window.innerWidth) left = mouseX - 500 - padding;
                    if (top + 400 > window.innerHeight) top = mouseY - 400 - padding;
                    return { x: Math.max(0, left), y: Math.max(0, top) };
                },

                maybeHideTooltip() {
                    setTimeout(() => {
                        if (!this.isHoveringTooltip) {
                            this.hoveredNode = null;
                            this.updateHighlights();
                        }
                    }, 100);
                },

                togglePin(layer, cIdx) {
                    const idx = this.pinnedNodes.findIndex(p => p.layer === layer && p.cIdx === cIdx);
                    if (idx >= 0) {
                        this.pinnedNodes.splice(idx, 1);
                    } else {
                        this.pinnedNodes.push({ layer, cIdx });
                        if (!this.activationContextsSummary) this.loadActivationContexts();
                    }
                    this.hoveredNode = null;
                    this.updateHighlights();
                },

                unpinNode(layer, cIdx) {
                    const idx = this.pinnedNodes.findIndex(p => p.layer === layer && p.cIdx === cIdx);
                    if (idx >= 0) this.pinnedNodes.splice(idx, 1);
                    this.updateHighlights();
                },

                isNodePinned(layer, cIdx) {
                    return this.pinnedNodes.some(p => p.layer === layer && p.cIdx === cIdx);
                },

                updateHighlights() {
                    const svg = this.$refs.graph;
                    if (!svg) return;

                    svg.querySelectorAll('.edge').forEach(el => el.classList.remove('highlighted'));
                    svg.querySelectorAll('.node').forEach(el => el.classList.remove('same-component'));

                    // Collect all highlighted component keys
                    const highlightedKeys = new Set();

                    // From pinned nodes
                    for (const pinned of this.pinnedNodes) {
                        svg.querySelectorAll('.node').forEach(el => {
                            if (el.getAttribute('data-layer') === pinned.layer &&
                                el.getAttribute('data-cidx') === String(pinned.cIdx)) {
                                const seq = el.getAttribute('data-seq');
                                highlightedKeys.add(`${pinned.layer}:${seq}:${pinned.cIdx}`);
                            }
                        });
                    }

                    // From hovered node (if not pinned)
                    if (this.hoveredNode && !this.isNodePinned(this.hoveredNode.layer, this.hoveredNode.cIdx)) {
                        svg.querySelectorAll('.node').forEach(el => {
                            if (el.getAttribute('data-layer') === this.hoveredNode.layer &&
                                el.getAttribute('data-cidx') === String(this.hoveredNode.cIdx)) {
                                const seq = el.getAttribute('data-seq');
                                highlightedKeys.add(`${this.hoveredNode.layer}:${seq}:${this.hoveredNode.cIdx}`);
                            }
                        });
                    }

                    // Apply highlights
                    svg.querySelectorAll('.edge').forEach(el => {
                        const src = el.getAttribute('data-src');
                        const tgt = el.getAttribute('data-tgt');
                        if (highlightedKeys.has(src) || highlightedKeys.has(tgt)) {
                            el.classList.add('highlighted');
                        }
                    });

                    svg.querySelectorAll('.node').forEach(el => {
                        const key = `${el.getAttribute('data-layer')}:${el.getAttribute('data-seq')}:${el.getAttribute('data-cidx')}`;
                        if (highlightedKeys.has(key)) {
                            el.classList.add('same-component');
                        }
                    });
                },

                async searchPrompts() {
                    if (this.pinnedNodes.length === 0) return;

                    this.searchLoading = true;
                    this.searchError = null;

                    try {
                        timeStart('search.total');
                        const components = this.pinnedNodes.map(p => `${p.layer}:${p.cIdx}`).join(',');

                        timeStart('search.fetch');
                        const response = await fetch(`${this.apiBase}/api/search?components=${encodeURIComponent(components)}&mode=all`);
                        if (!response.ok) {
                            throw new Error(`Server error: ${response.status} ${response.statusText}`);
                        }
                        const result = await response.json();
                        timeEnd('search.fetch');

                        if (result.error) {
                            throw new Error(result.error);
                        }

                        this.searchResults = result.results;
                        timeEnd('search.total');
                        console.log(`[timing] search found ${result.results.length} results`);
                    } catch (e) {
                        console.error('Error searching prompts:', e);
                        this.searchError = `Search failed: ${e.message}`;
                        this.searchResults = [];
                        timeEnd('search.total');
                    } finally {
                        this.searchLoading = false;
                    }
                },

                // Helper to build just the local section (always available, doesn't need activation contexts)
                buildLocalSectionHtml(layer, seqIdx, cIdx) {
                    let countEdges = 0;
                    for (const edge of this.allEdges) {
                        const [srcLayer, srcSeq, srcCIdx] = edge.srcKey.split(':');
                        const [tgtLayer, tgtSeq, tgtCIdx] = edge.tgtKey.split(':');
                        if ((srcLayer === layer && +srcSeq === seqIdx && +srcCIdx === cIdx) ||
                            (tgtLayer === layer && +tgtSeq === seqIdx && +tgtCIdx === cIdx)) {
                            countEdges++;
                        }
                    }
                    const nodeKey = `${layer}:${seqIdx}:${cIdx}`;
                    const importance = this.componentImportanceLocal[nodeKey] || 0;

                    let html = `<div class="node-local-section">`;
                    html += `<h4>Node @ Position ${seqIdx}</h4>`;
                    html += `<div><strong>Edges:</strong> ${countEdges} | <strong>Importance:</strong> ${importance.toFixed(4)}</div>`;
                    html += `</div>`;
                    return html;
                },

                buildComponentHtml(layer, seqIdx, cIdx) {
                    // Count edges for this component at this position
                    let countEdges = 0;
                    for (const edge of this.allEdges) {
                        const [srcLayer, srcSeq, srcCIdx] = edge.srcKey.split(':');
                        const [tgtLayer, tgtSeq, tgtCIdx] = edge.tgtKey.split(':');
                        if ((srcLayer === layer && +srcSeq === seqIdx && +srcCIdx === cIdx) ||
                            (tgtLayer === layer && +tgtSeq === seqIdx && +tgtCIdx === cIdx)) {
                            countEdges++;
                        }
                    }

                    // Special handling for output nodes
                    if (layer === 'output') {
                        // Collect all tokens at this sequence position
                        const tokensAtPos = [];
                        for (const [probKey, entry] of Object.entries(this.promptData.outputProbs)) {
                            const [s, tokenId] = probKey.split(':');
                            if (+s === seqIdx) {
                                tokensAtPos.push({ tokenId: +tokenId, prob: entry.prob, token: entry.token });
                            }
                        }
                        if (tokensAtPos.length === 0) {
                            throw new Error(`No outputProbs entries found for sequence position ${seqIdx}`);
                        }
                        // Sort by probability descending
                        tokensAtPos.sort((a, b) => b.prob - a.prob);

                        // Find the hovered token's entry
                        const hoveredEntry = tokensAtPos.find(t => t.tokenId === cIdx);
                        if (!hoveredEntry) {
                            throw new Error(`Hovered token ${cIdx} not found in outputProbs for position ${seqIdx}`);
                        }

                        // Header with large token and probability, gradient background based on prob
                        const probPercent = (hoveredEntry.prob * 100).toFixed(1);
                        // Use a green gradient: higher prob = more saturated green
                        const headerBg = `linear-gradient(90deg, rgba(76, 175, 80, ${Math.min(0.8, hoveredEntry.prob + 0.1)}) 0%, rgba(76, 175, 80, 0.1) 100%)`;
                        let html = `<div style="background: ${headerBg}; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px;">`;
                        html += `<div style="font-size: 1.4em; font-weight: bold;">"${this.escapeHtml(hoveredEntry.token)}"</div>`;
                        html += `<div style="font-size: 1.1em; color: #333;">${probPercent}% probability</div>`;
                        html += `</div>`;

                        html += `<p class="stats"><strong>Position:</strong> ${seqIdx} | <strong>Vocab ID:</strong> ${cIdx} | <strong>Edges:</strong> ${countEdges}</p>`;

                        // Table of all tokens at this position
                        html += `<h4>All Tokens at Position ${seqIdx}</h4>`;
                        html += `<table class="pr-table"><tr><th>Token</th><th>Prob</th></tr>`;
                        for (const t of tokensAtPos) {
                            const isHovered = t.tokenId === cIdx;
                            const rowStyle = isHovered ? 'background: rgba(76, 175, 80, 0.3); font-weight: bold;' : '';
                            html += `<tr style="${rowStyle}"><td><code>${this.escapeHtml(t.token)}</code></td><td>${(t.prob * 100).toFixed(2)}%</td></tr>`;
                        }
                        html += `</table>`;
                        return html;
                    }

                    // Regular component handling
                    // Note: local section is rendered separately before the h3
                    // Get summary data for mean_ci
                    const summary = this.activationContextsSummary?.[layer]?.find(s => s.subcomponent_idx === cIdx);
                    // Get detail data (lazy-loaded) for examples, pr_tokens, etc.
                    const detail = this.getComponentDetail(layer, cIdx);
                    const cacheKey = `${layer}:${cIdx}`;
                    const isLoading = this.componentDetailsLoading[cacheKey];

                    if (!summary && !detail) {
                        return `<p style="color: #666;">No activation context data</p>`;
                    }

                    // Component-wide section
                    let html = `<div class="component-section">`;
                    const meanCi = detail?.mean_ci ?? summary?.mean_ci;
                    if (meanCi !== undefined) {
                        html += `<p class="stats"><strong>Mean CI:</strong> ${meanCi.toFixed(4)}</p>`;
                    }

                    // Detail section (lazy-loaded)
                    if (detail) {
                        if (detail.example_tokens?.length > 0) {
                            html += '<h4>Top Activating Examples</h4>';
                            for (let i = 0; i < Math.min(50, detail.example_tokens.length); i++) {
                                const tokens = detail.example_tokens[i];
                                const ciVals = detail.example_ci[i];
                                const activePos = detail.example_active_pos[i];

                                html += `<div class="example-row">`;
                                for (let j = 0; j < tokens.length; j++) {
                                    const ci = ciVals[j];
                                    const isActive = j === activePos;
                                    const bg = `rgba(255, 100, 100, ${Math.min(1, ci * 5)})`;
                                    html += `<span class="example-token${isActive ? ' active' : ''}" style="background:${bg}">${this.escapeHtml(tokens[j])}</span>`;
                                }
                                html += `</div>`;
                            }
                        }

                        html += '<div class="tables-row">';
                        if (detail.pr_tokens?.length > 0) {
                            // Sort by precision descending (backend sorts by recall)
                            const prIndices = detail.pr_precisions
                                .map((p, i) => [p, i])
                                .sort((a, b) => b[0] - a[0])
                                .map(x => x[1]);
                            html += '<div><h4>Top Input Tokens</h4><table class="pr-table"><tr><th>Token</th><th>P(fire|tok)</th></tr>';
                            for (let j = 0; j < Math.min(5, prIndices.length); j++) {
                                const i = prIndices[j];
                                html += `<tr><td><code>${this.escapeHtml(detail.pr_tokens[i])}</code></td><td>${detail.pr_precisions[i].toFixed(3)}</td></tr>`;
                            }
                            html += '</table></div>';
                        }
                        if (detail.predicted_tokens?.length > 0) {
                            html += '<div><h4>Top Predicted</h4><table class="pr-table"><tr><th>Token</th><th>P</th></tr>';
                            for (let i = 0; i < Math.min(5, detail.predicted_tokens.length); i++) {
                                html += `<tr><td><code>${this.escapeHtml(detail.predicted_tokens[i])}</code></td><td>${detail.predicted_probs[i].toFixed(3)}</td></tr>`;
                            }
                            html += '</table></div>';
                        }
                        html += '</div>';
                    } else if (isLoading) {
                        html += '<p class="loading-text"><span class="loading-spinner"></span> Loading examples...</p>';
                    }

                    html += '</div>'; // close component-section

                    return html;
                },

                // Seq-agnostic version for pinned components
                buildComponentHtmlNoSeq(layer, cIdx) {
                    // Count total edges across all seq positions for this component
                    let countEdges = 0;
                    for (const edge of this.allEdges) {
                        const [srcLayer, , srcCIdx] = edge.srcKey.split(':');
                        const [tgtLayer, , tgtCIdx] = edge.tgtKey.split(':');
                        if ((srcLayer === layer && +srcCIdx === cIdx) ||
                            (tgtLayer === layer && +tgtCIdx === cIdx)) {
                            countEdges++;
                        }
                    }

                    // Special handling for output nodes
                    if (layer === 'output') {
                        // Find all positions where this token appears
                        const positions = [];
                        for (const [probKey, entry] of Object.entries(this.promptData.outputProbs)) {
                            const [seqIdx, tokenId] = probKey.split(':');
                            if (+tokenId === cIdx) {
                                positions.push({ seqIdx: +seqIdx, prob: entry.prob, token: entry.token });
                            }
                        }
                        if (positions.length === 0) {
                            throw new Error(`No outputProbs entry found for output component ${cIdx}`);
                        }
                        positions.sort((a, b) => b.prob - a.prob);
                        const entry = positions[0];

                        let html = `<p><strong style="font-size: 1.2em;">"${this.escapeHtml(entry.token)}"</strong></p>`;
                        html += `<p class="stats"><strong>Vocab ID:</strong> ${cIdx} | <strong>Edges:</strong> ${countEdges}</p>`;
                        html += `<h4>Probability by Position</h4>`;
                        html += `<table class="pr-table"><tr><th>Pos</th><th>Prob</th></tr>`;
                        for (const pos of positions) {
                            html += `<tr><td>${pos.seqIdx}</td><td>${(pos.prob * 100).toFixed(2)}%</td></tr>`;
                        }
                        html += `</table>`;
                        return html;
                    }

                    // Regular component handling (same as buildComponentHtml but without seq-specific edge counting)
                    // Get summary data for mean_ci
                    const summary = this.activationContextsSummary?.[layer]?.find(s => s.subcomponent_idx === cIdx);
                    // Get detail data (lazy-loaded) for examples, pr_tokens, etc.
                    const detail = this.getComponentDetail(layer, cIdx);
                    const cacheKey = `${layer}:${cIdx}`;
                    const isLoading = this.componentDetailsLoading[cacheKey];

                    if (!summary && !detail) {
                        return `<p class="stats"><strong>Edges:</strong> ${countEdges}</p><p style="color: #666;">No activation context data</p>`;
                    }

                    const meanCi = detail?.mean_ci ?? summary?.mean_ci;
                    let html = `<p class="stats"><strong>Mean CI:</strong> ${meanCi?.toFixed(4) ?? '?'} | <strong>Edges:</strong> ${countEdges}</p>`;

                    // Detail section (lazy-loaded)
                    if (detail) {
                        if (detail.example_tokens?.length > 0) {
                            html += '<h4>Top Activating Examples</h4>';
                            for (let i = 0; i < Math.min(50, detail.example_tokens.length); i++) {
                                const tokens = detail.example_tokens[i];
                                const ciVals = detail.example_ci[i];
                                const activePos = detail.example_active_pos[i];

                                html += `<div class="example-row">`;
                                for (let j = 0; j < tokens.length; j++) {
                                    const ci = ciVals[j];
                                    const isActive = j === activePos;
                                    const bg = `rgba(255, 100, 100, ${Math.min(1, ci * 5)})`;
                                    html += `<span class="example-token${isActive ? ' active' : ''}" style="background:${bg}">${this.escapeHtml(tokens[j])}</span>`;
                                }
                                html += `</div>`;
                            }
                        }

                        html += '<div class="tables-row">';
                        if (detail.pr_tokens?.length > 0) {
                            // Sort by precision descending (backend sorts by recall)
                            const prIndices = detail.pr_precisions
                                .map((p, i) => [p, i])
                                .sort((a, b) => b[0] - a[0])
                                .map(x => x[1]);
                            html += '<div><h4>Top Input Tokens</h4><table class="pr-table"><tr><th>Token</th><th>P(fire|tok)</th></tr>';
                            for (let j = 0; j < Math.min(5, prIndices.length); j++) {
                                const i = prIndices[j];
                                html += `<tr><td><code>${this.escapeHtml(detail.pr_tokens[i])}</code></td><td>${detail.pr_precisions[i].toFixed(3)}</td></tr>`;
                            }
                            html += '</table></div>';
                        }
                        if (detail.predicted_tokens?.length > 0) {
                            html += '<div><h4>Top Predicted</h4><table class="pr-table"><tr><th>Token</th><th>P</th></tr>';
                            for (let i = 0; i < Math.min(5, detail.predicted_tokens.length); i++) {
                                html += `<tr><td><code>${this.escapeHtml(detail.predicted_tokens[i])}</code></td><td>${detail.predicted_probs[i].toFixed(3)}</td></tr>`;
                            }
                            html += '</table></div>';
                        }
                        html += '</div>';
                    } else if (isLoading) {
                        html += '<p class="loading-text"><span class="loading-spinner"></span> Loading examples...</p>';
                    }

                    return html;
                },

                escapeHtml(text) {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                }
            };
        }
    </script>
</body>
</html>
