<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Attributions Graph</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #fafafa;
            display: flex;
            height: 100vh;
        }
        /* Sidebar styles */
        .sidebar {
            width: 280px;
            background: #fff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
            background: #f5f5f5;
        }
        .sidebar-header h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; }
        .search-btn {
            width: 100%;
            padding: 0.5rem;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .search-btn:hover { background: #1976d2; }
        .search-btn:disabled { background: #ccc; cursor: not-allowed; }
        .search-info {
            padding: 0.5rem 1rem;
            background: #e3f2fd;
            font-size: 0.8rem;
            color: #1565c0;
        }
        .search-results {
            flex: 1;
            overflow-y: auto;
        }
        .search-result {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.15s;
        }
        .search-result:hover { background: #f5f5f5; }
        .search-result.active { background: #e3f2fd; border-left: 3px solid #2196f3; }
        .search-result-id { font-size: 0.75rem; color: #666; margin-bottom: 0.25rem; }
        .search-result-preview {
            font-family: monospace;
            font-size: 0.8rem;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* Main content */
        .main-content {
            flex: 1;
            padding: 1rem;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }
        h1 { margin-top: 0; font-size: 1.5rem; }
        .controls {
            display: flex;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-wrap: wrap;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .controls input[type="number"] {
            width: 80px;
            padding: 0.25rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .controls select {
            padding: 0.25rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }
        .edge-count { color: #666; font-size: 0.9rem; }
        .db-info { color: #666; font-size: 0.85rem; margin-left: auto; }
        .graph-wrapper {
            display: flex;
            max-height: 70vh;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .layer-labels-container {
            position: sticky;
            left: 0;
            background: white;
            border-right: 1px solid #eee;
            z-index: 11;
            flex-shrink: 0;
        }
        .graph-container {
            overflow: auto;
            flex: 1;
            position: relative;
        }
        .token-labels-container {
            position: sticky;
            bottom: 0;
            background: white;
            border-top: 1px solid #eee;
            z-index: 10;
        }
        svg { display: block; }
        .legend {
            margin-top: 1rem;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .legend h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; }
        .legend-items { display: flex; flex-wrap: wrap; gap: 1rem; }
        .legend-item { display: flex; align-items: center; gap: 0.25rem; font-size: 0.85rem; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        .legend-edge { margin-top: 0.5rem; font-size: 0.85rem; display: flex; align-items: center; gap: 1rem; }
        .edge-pos, .edge-neg { display: inline-block; width: 30px; height: 3px; margin-right: 0.25rem; }
        .edge-pos { background: #2196f3; }
        .edge-neg { background: #f44336; }
        .loading { padding: 2rem; text-align: center; color: #666; }
        .node-details {
            position: fixed;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            max-width: 1000px;
            max-height: 800px;
            overflow-y: auto;
            z-index: 1000;
            pointer-events: auto;
        }
        .pinned-container {
            margin-top: 1rem;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .pinned-container h3 {
            margin: 0 0 0.75rem 0;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .pinned-items {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }
        .pinned-item {
            flex-shrink: 0;
            min-width: 350px;
            max-width: 500px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
            background: #fafafa;
        }
        .pinned-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .unpin-btn {
            cursor: pointer;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }
        .edge { transition: opacity 0.15s, stroke-width 0.15s; }
        .edge.highlighted { opacity: 1 !important; stroke-width: 3 !important; }
        .node { transition: stroke-width 0.15s, filter 0.15s; cursor: pointer; }
        .node.same-component {
            stroke: #000 !important;
            stroke-width: 2.5 !important;
            filter: brightness(0.7) saturate(1.5);
            opacity: 1 !important;
        }
        .example-row {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin: 0.5rem 0;
            font-family: monospace;
            font-size: 0.85rem;
        }
        .example-token {
            padding: 2px 4px;
            border-radius: 2px;
        }
        .example-token.active {
            font-weight: bold;
            border: 1px solid #333;
        }
        .pr-table { font-size: 0.85rem; margin-top: 0.5rem; }
        .pr-table th, .pr-table td { padding: 0.25rem 0.5rem; text-align: left; }
        .stats { margin: 0.25rem 0; font-size: 0.85rem; }
        h4 { margin: 0.75rem 0 0.25rem 0; font-size: 0.85rem; }
        .tables-row { display: flex; gap: 2rem; flex-wrap: wrap; }
    </style>
</head>
<body x-data="app()" x-init="init()">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h3>Search Prompts</h3>
            <button
                class="search-btn"
                :disabled="pinnedNodes.length === 0"
                @click="searchPrompts"
                x-text="pinnedNodes.length === 0 ? 'Pin components to search' : `Find prompts with ${pinnedNodes.length} pinned component${pinnedNodes.length > 1 ? 's' : ''}`"
            ></button>
        </div>
        <div class="search-info" x-show="searchResults.length > 0">
            Found <span x-text="searchResults.length"></span> prompt<span x-show="searchResults.length !== 1">s</span>
        </div>
        <div class="search-results">
            <template x-for="p in searchResults" :key="p.id">
                <div
                    class="search-result"
                    :class="{ active: p.id === currentPromptId }"
                    @click="loadPrompt(p.id)"
                >
                    <div class="search-result-id">Prompt #<span x-text="p.id"></span></div>
                    <div class="search-result-preview" x-text="p.preview"></div>
                </div>
            </template>
        </div>
    </div>

    <!-- Main content -->
    <div class="main-content">
        <h1>Local Attributions Graph</h1>

        <!-- Loading state -->
        <div class="loading" x-show="loading" x-text="loadingMessage"></div>

        <!-- Main app -->
        <div x-show="!loading">
            <div class="controls">
                <label>
                    Prompt:
                    <select x-model="currentPromptId" @change="loadPrompt(parseInt($event.target.value))">
                        <template x-for="p in allPrompts" :key="p.id">
                            <option :value="p.id" x-text="`${p.id}: ${p.preview}`"></option>
                        </template>
                    </select>
                </label>
                <label>
                    Max mean CI:
                    <input type="number" x-model.number="maxMeanCI" min="0" max="1" step="0.01" @change="reloadWithFilters()">
                </label>
                <label>
                    Top K edges:
                    <input type="number" x-model.number="topK" min="10" max="10000" step="100" @change="reloadWithFilters()">
                </label>
                <span class="edge-count">Showing <span x-text="visibleEdgeCount"></span> edges</span>
                <span class="db-info">DB: <span x-text="promptCount"></span> prompts</span>
            </div>

            <div class="graph-wrapper">
                <div class="layer-labels-container" x-ref="layerLabels"></div>
                <div class="graph-container">
                    <svg x-ref="graph"></svg>
                    <div class="token-labels-container" x-ref="tokenLabels"></div>
                </div>
            </div>

            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-items">
                    <template x-for="(color, name) in COLORS" :key="name">
                        <div class="legend-item">
                            <span class="legend-dot" :style="`background: ${color}`"></span>
                            <span x-text="name"></span>
                        </div>
                    </template>
                </div>
                <div class="legend-edge">
                    <span class="edge-pos"></span> Positive
                    <span class="edge-neg"></span> Negative
                </div>
            </div>

            <!-- Pinned components -->
            <div class="pinned-container" x-show="pinnedNodes.length > 0">
                <h3>
                    <span>Pinned Components</span>
                    <button @click="pinnedNodes = []" style="font-size: 0.8rem; padding: 0.25rem 0.5rem; cursor: pointer;">Clear all</button>
                </h3>
                <div x-show="!activationContexts" class="loading">Loading component details...</div>
                <div class="pinned-items" x-show="activationContexts">
                    <template x-for="pinned in pinnedNodes" :key="`${pinned.layer}:${pinned.cIdx}`">
                        <div class="pinned-item">
                            <div class="pinned-item-header">
                                <strong x-text="`${pinned.layer} : ${pinned.cIdx}`"></strong>
                                <button class="unpin-btn" @click="unpinNode(pinned.layer, pinned.cIdx)">âœ• unpin</button>
                            </div>
                            <template x-if="activationContexts">
                                <div x-html="buildComponentHtml(pinned.layer, pinned.cIdx)"></div>
                            </template>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Hover tooltip -->
            <div
                class="node-details"
                x-show="hoveredNode && !isNodePinned(hoveredNode.layer, hoveredNode.cIdx)"
                :style="`left: ${tooltipPos.x}px; top: ${tooltipPos.y}px`"
                @mouseenter="isHoveringTooltip = true"
                @mouseleave="isHoveringTooltip = false; maybeHideTooltip()"
            >
                <h3>Component Details</h3>
                <template x-if="hoveredNode && !activationContexts">
                    <div>
                        <p><strong x-text="`${hoveredNode.layer} : ${hoveredNode.cIdx}`"></strong></p>
                        <p>Loading details...</p>
                    </div>
                </template>
                <template x-if="hoveredNode && activationContexts">
                    <div x-html="buildComponentHtml(hoveredNode.layer, hoveredNode.cIdx)"></div>
                </template>
            </div>
        </div>
    </div>

    <script>
        const COMPONENT_SIZE = 8;
        const COMPONENT_GAP = 2;
        const LAYER_GAP = 30;
        const MARGIN = { top: 60, right: 40, bottom: 20, left: 20 };
        const LABEL_WIDTH = 100;
        const SUBTYPE_ORDER = ['q_proj', 'k_proj', 'v_proj', 'o_proj', 'c_fc', 'down_proj'];
        const COLORS = {
            q_proj: "#e91e63", k_proj: "#9c27b0", v_proj: "#673ab7",
            o_proj: "#3f51b5", c_fc: "#009688", down_proj: "#4caf50"
        };

        // Simple timing utility that avoids duplicate timer warnings
        const timers = {};
        function timeStart(label) {
            timers[label] = performance.now();
        }
        function timeEnd(label) {
            if (timers[label]) {
                const duration = performance.now() - timers[label];
                console.log(`[timing] ${label}: ${duration.toFixed(1)}ms`);
                delete timers[label];
            }
        }

        function app() {
            return {
                // Constants
                COLORS,

                // API
                apiBase: window.location.origin || 'http://localhost:8765',

                // Loading state
                loading: true,
                loadingMessage: 'Loading data...',

                // Data
                promptCount: 0,
                allPrompts: [],
                currentPromptId: null,
                promptData: null,
                activationContexts: null,
                activationContextsLoading: false,

                // Computed from prompt data
                allEdges: [],
                componentImportance: {},
                componentImportanceLocal: {},
                nodeOutAttr: {},
                maxAttr: 1,
                maxNodeOutAttr: 1,

                // UI state
                maxMeanCI: 1.0,  // No CI filtering by default
                topK: 1000,
                visibleEdgeCount: 0,
                pinnedNodes: [],
                hoveredNode: null,
                isHoveringTooltip: false,
                tooltipPos: { x: 0, y: 0 },
                searchResults: [],

                // Layout cache
                layerYPositions: {},
                nodePositions: {},

                // Event delegation bound flag
                svgListenersBound: false,

                async init() {
                    timeStart('init.total');
                    try {
                        timeStart('init.fetchMeta');
                        const meta = await fetch(`${this.apiBase}/api/meta`).then(r => r.json());
                        timeEnd('init.fetchMeta');
                        this.promptCount = meta.prompt_count;

                        if (meta.prompt_count > 0) {
                            // Load first prompt immediately
                            await this.loadPrompt(1);

                            // Load prompts list in background
                            timeStart('init.fetchPromptsList');
                            fetch(`${this.apiBase}/api/prompts`)
                                .then(r => r.json())
                                .then(prompts => {
                                    timeEnd('init.fetchPromptsList');
                                    this.allPrompts = prompts;
                                });

                            // Load activation contexts in background
                            this.loadActivationContexts();
                        } else {
                            this.loadingMessage = 'No prompts in database';
                        }
                    } catch (e) {
                        this.loadingMessage = 'Error connecting to server. Make sure it is running.';
                        console.error(e);
                    }
                    timeEnd('init.total');
                },

                async loadPrompt(promptId) {
                    timeStart('loadPrompt.total');
                    this.currentPromptId = promptId;

                    // Fetch with server-side filtering
                    const params = new URLSearchParams({
                        top_k: this.topK,
                        max_mean_ci: this.maxMeanCI,
                    });

                    timeStart('loadPrompt.fetch');
                    const promptData = await fetch(`${this.apiBase}/api/prompt/${promptId}?${params}`).then(r => r.json());
                    timeEnd('loadPrompt.fetch');

                    this.promptData = promptData;

                    timeStart('loadPrompt.process');
                    this.processPromptData();
                    timeEnd('loadPrompt.process');

                    this.loading = false;
                    this.$nextTick(() => {
                        timeStart('loadPrompt.render');
                        this.render();
                        timeEnd('loadPrompt.render');
                        timeEnd('loadPrompt.total');
                    });
                },

                async reloadWithFilters() {
                    // Re-fetch current prompt with new filter params
                    if (this.currentPromptId) {
                        await this.loadPrompt(this.currentPromptId);
                    }
                },

                async loadActivationContexts() {
                    if (this.activationContexts || this.activationContextsLoading) return;
                    this.activationContextsLoading = true;

                    timeStart('loadActCtx.fetch');
                    try {
                        this.activationContexts = await fetch(`${this.apiBase}/api/activation_contexts`).then(r => r.json());
                        timeEnd('loadActCtx.fetch');
                        // No re-render needed - CI filtering is now server-side
                        // Activation contexts are only used for tooltips/pinned details
                    } catch (e) {
                        console.error('Error loading activation contexts:', e);
                    }
                    this.activationContextsLoading = false;
                },

                processPromptData() {
                    const data = this.promptData;

                    // Check if we got the new format (edges) or old format (pairs)
                    if (!data.edges) {
                        console.error('Server returned old format (pairs) instead of new format (edges). Make sure you are running the new server: python -m spd.attributions.server');
                        console.log('Response keys:', Object.keys(data));
                        return;
                    }

                    // New format: edges are pre-filtered and sorted by server
                    // Each edge: { src: "layer:seq:cIdx", tgt: "layer:seq:cIdx", val: float }
                    this.allEdges = data.edges.map(e => ({
                        srcKey: e.src,
                        tgtKey: e.tgt,
                        val: e.val,
                    }));

                    // Find max attribution
                    this.maxAttr = Math.max(...this.allEdges.map(e => Math.abs(e.val)), 1);

                    // Build importance maps from edges
                    this.componentImportance = {};
                    this.componentImportanceLocal = {};
                    this.nodeOutAttr = {};

                    for (const edge of this.allEdges) {
                        const valSq = edge.val * edge.val;
                        const absVal = Math.abs(edge.val);

                        // Parse keys to get global component key (layer:cIdx without seq)
                        const [srcLayer, , srcCIdx] = edge.srcKey.split(':');
                        const [tgtLayer, , tgtCIdx] = edge.tgtKey.split(':');
                        const srcGlobalKey = `${srcLayer}:${srcCIdx}`;
                        const tgtGlobalKey = `${tgtLayer}:${tgtCIdx}`;

                        this.componentImportance[srcGlobalKey] = (this.componentImportance[srcGlobalKey] || 0) + valSq;
                        this.componentImportance[tgtGlobalKey] = (this.componentImportance[tgtGlobalKey] || 0) + valSq;
                        this.componentImportanceLocal[edge.srcKey] = (this.componentImportanceLocal[edge.srcKey] || 0) + valSq;
                        this.componentImportanceLocal[edge.tgtKey] = (this.componentImportanceLocal[edge.tgtKey] || 0) + valSq;

                        this.nodeOutAttr[edge.srcKey] = (this.nodeOutAttr[edge.srcKey] || 0) + absVal;
                    }

                    this.maxNodeOutAttr = Math.max(...Object.values(this.nodeOutAttr), 1);
                },

                parseLayer(name) {
                    const m = name.match(/h\.(\d+)\.(attn|mlp)\.(\w+)/);
                    return m ? { name, block: +m[1], type: m[2], subtype: m[3] } : null;
                },

                getFilteredEdgesAndNodes() {
                    // Server already filtered by top_k and max_mean_ci
                    // Just build the active nodes set
                    const activeNodes = new Set();
                    for (const edge of this.allEdges) {
                        activeNodes.add(edge.srcKey);
                        activeNodes.add(edge.tgtKey);
                    }
                    return { edges: this.allEdges, activeNodes };
                },

                buildLayout(activeNodes) {
                    const nodesPerLayerSeq = {};
                    const allLayers = new Set();

                    for (const nodeKey of activeNodes) {
                        const [layer, seqIdx, cIdx] = nodeKey.split(':');
                        allLayers.add(layer);
                        const key = `${layer}:${seqIdx}`;
                        if (!nodesPerLayerSeq[key]) nodesPerLayerSeq[key] = [];
                        nodesPerLayerSeq[key].push(+cIdx);
                    }

                    const layers = Array.from(allLayers).sort((a, b) => {
                        const infoA = this.parseLayer(a);
                        const infoB = this.parseLayer(b);
                        if (infoA.block !== infoB.block) return infoA.block - infoB.block;
                        return SUBTYPE_ORDER.indexOf(infoA.subtype) - SUBTYPE_ORDER.indexOf(infoB.subtype);
                    });

                    this.layerYPositions = {};
                    let currentY = MARGIN.top;
                    for (const layer of layers.slice().reverse()) {
                        this.layerYPositions[layer] = currentY;
                        currentY += COMPONENT_SIZE + LAYER_GAP;
                    }

                    const tokens = this.promptData.tokens;
                    const maxComponentsPerSeq = tokens.map((_, seqIdx) => {
                        return Math.max(...layers.map(layer =>
                            (nodesPerLayerSeq[`${layer}:${seqIdx}`] || []).length
                        ), 0);
                    });

                    const MIN_COL_WIDTH = 30, COL_PADDING = 16;
                    const seqWidths = maxComponentsPerSeq.map(n =>
                        Math.max(MIN_COL_WIDTH, n * (COMPONENT_SIZE + COMPONENT_GAP) + COL_PADDING * 2)
                    );
                    const seqXStarts = [MARGIN.left];
                    for (let i = 0; i < seqWidths.length - 1; i++) {
                        seqXStarts.push(seqXStarts[i] + seqWidths[i]);
                    }

                    this.nodePositions = {};
                    for (const layer of layers) {
                        for (let seqIdx = 0; seqIdx < tokens.length; seqIdx++) {
                            const components = (nodesPerLayerSeq[`${layer}:${seqIdx}`] || []).sort((a, b) => {
                                const impA = this.componentImportanceLocal[`${layer}:${seqIdx}:${a}`] || 0;
                                const impB = this.componentImportanceLocal[`${layer}:${seqIdx}:${b}`] || 0;
                                return impB - impA;
                            });

                            const baseX = seqXStarts[seqIdx] + COL_PADDING;
                            const baseY = this.layerYPositions[layer];

                            for (let i = 0; i < components.length; i++) {
                                const cIdx = components[i];
                                this.nodePositions[`${layer}:${seqIdx}:${cIdx}`] = {
                                    x: baseX + i * (COMPONENT_SIZE + COMPONENT_GAP) + COMPONENT_SIZE / 2,
                                    y: baseY + COMPONENT_SIZE / 2
                                };
                            }
                        }
                    }

                    return { layers, seqWidths, seqXStarts };
                },

                render() {
                    if (!this.promptData) return;

                    timeStart('render.filter');
                    const { edges, activeNodes } = this.getFilteredEdgesAndNodes();
                    timeEnd('render.filter');
                    this.visibleEdgeCount = edges.length;

                    timeStart('render.layout');
                    const { layers, seqWidths, seqXStarts } = this.buildLayout(activeNodes);
                    timeEnd('render.layout');
                    const tokens = this.promptData.tokens;

                    const totalSeqWidth = seqXStarts[seqXStarts.length - 1] + seqWidths[seqWidths.length - 1];
                    const width = totalSeqWidth + MARGIN.right;
                    const maxY = Math.max(...Object.values(this.layerYPositions), 0) + COMPONENT_SIZE;
                    const height = maxY + MARGIN.bottom;

                    // Render main graph
                    const svg = this.$refs.graph;
                    svg.setAttribute('width', width);
                    svg.setAttribute('height', height);

                    timeStart('render.buildHtml');
                    let html = '';
                    for (const e of edges) {
                        const p1 = this.nodePositions[e.srcKey];
                        const p2 = this.nodePositions[e.tgtKey];
                        if (p1 && p2) {
                            const color = e.val > 0 ? '#2196f3' : '#f44336';
                            const w = Math.max(0.5, (Math.abs(e.val) / this.maxAttr) * 2);
                            const op = 0.05 + (Math.abs(e.val) / this.maxAttr) * 0.95;
                            html += `<line class="edge" data-src="${e.srcKey}" data-tgt="${e.tgtKey}" x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="${color}" stroke-width="${w}" opacity="${op}"/>`;
                        }
                    }

                    for (const key in this.nodePositions) {
                        const pos = this.nodePositions[key];
                        const [layer, seqIdx, cIdx] = key.split(':');
                        const info = this.parseLayer(layer);
                        const outAttr = this.nodeOutAttr[key] || 0;
                        const intensity = Math.min(1, outAttr / this.maxNodeOutAttr);
                        const baseColor = COLORS[info.subtype] || '#999';
                        const opacity = 0.2 + intensity * 0.8;
                        html += `<rect class="node" data-layer="${layer}" data-seq="${seqIdx}" data-cidx="${cIdx}" x="${pos.x - COMPONENT_SIZE/2}" y="${pos.y - COMPONENT_SIZE/2}" width="${COMPONENT_SIZE}" height="${COMPONENT_SIZE}" fill="${baseColor}" rx="1" opacity="${opacity}"><title>${layer} seq=${seqIdx} c=${cIdx}</title></rect>`;
                    }
                    timeEnd('render.buildHtml');

                    timeStart('render.svgInnerHTML');
                    svg.innerHTML = html;
                    timeEnd('render.svgInnerHTML');

                    // Token labels
                    timeStart('render.tokenLabels');
                    let tokenHtml = `<svg width="${width}" height="50" style="display:block;">`;
                    for (let i = 0; i < tokens.length; i++) {
                        const colCenter = seqXStarts[i] + seqWidths[i] / 2;
                        tokenHtml += `<text x="${colCenter}" y="20" text-anchor="middle" font-size="12" font-family="monospace" font-weight="500">${this.escapeHtml(tokens[i])}</text>`;
                        tokenHtml += `<text x="${colCenter}" y="38" text-anchor="middle" font-size="10" fill="#999">[${i}]</text>`;
                    }
                    tokenHtml += '</svg>';
                    this.$refs.tokenLabels.innerHTML = tokenHtml;
                    timeEnd('render.tokenLabels');

                    // Layer labels
                    timeStart('render.layerLabels');
                    let layerHtml = `<svg width="${LABEL_WIDTH}" height="${height}" style="display:block;">`;
                    for (const layer in this.layerYPositions) {
                        const info = this.parseLayer(layer);
                        const y = this.layerYPositions[layer] + COMPONENT_SIZE / 2;
                        layerHtml += `<text x="${LABEL_WIDTH - 10}" y="${y}" text-anchor="end" dominant-baseline="middle" font-size="11" font-weight="500" fill="${COLORS[info.subtype]}">${info.subtype}</text>`;
                    }
                    layerHtml += '</svg>';
                    this.$refs.layerLabels.innerHTML = layerHtml;
                    timeEnd('render.layerLabels');

                    // Bind event delegation (only once)
                    this.bindSvgEventDelegation();

                    timeStart('render.highlights');
                    this.updateHighlights();
                    timeEnd('render.highlights');
                },

                bindSvgEventDelegation() {
                    if (this.svgListenersBound) return;
                    this.svgListenersBound = true;

                    const svg = this.$refs.graph;

                    // Event delegation for mouse events on nodes
                    svg.addEventListener('mouseover', (e) => {
                        const node = e.target.closest('.node');
                        if (!node) return;

                        const layer = node.getAttribute('data-layer');
                        const cIdx = parseInt(node.getAttribute('data-cidx'));
                        this.hoveredNode = { layer, cIdx };
                        this.tooltipPos = this.calcTooltipPos(e.clientX, e.clientY);
                        this.updateHighlights();
                        if (!this.activationContexts) this.loadActivationContexts();
                    });

                    svg.addEventListener('mouseout', (e) => {
                        const node = e.target.closest('.node');
                        if (!node) return;
                        // Check if we're moving to another node or leaving entirely
                        const related = e.relatedTarget?.closest?.('.node');
                        if (!related) {
                            this.maybeHideTooltip();
                        }
                    });

                    svg.addEventListener('click', (e) => {
                        const node = e.target.closest('.node');
                        if (!node) return;

                        timeStart('click.togglePin');
                        const layer = node.getAttribute('data-layer');
                        const cIdx = parseInt(node.getAttribute('data-cidx'));
                        this.togglePin(layer, cIdx);
                        timeEnd('click.togglePin');
                    });
                },

                calcTooltipPos(mouseX, mouseY) {
                    const padding = 15;
                    let left = mouseX + padding;
                    let top = mouseY + padding;
                    if (left + 500 > window.innerWidth) left = mouseX - 500 - padding;
                    if (top + 400 > window.innerHeight) top = mouseY - 400 - padding;
                    return { x: Math.max(0, left), y: Math.max(0, top) };
                },

                maybeHideTooltip() {
                    setTimeout(() => {
                        if (!this.isHoveringTooltip) {
                            this.hoveredNode = null;
                            this.updateHighlights();
                        }
                    }, 100);
                },

                togglePin(layer, cIdx) {
                    const idx = this.pinnedNodes.findIndex(p => p.layer === layer && p.cIdx === cIdx);
                    if (idx >= 0) {
                        this.pinnedNodes.splice(idx, 1);
                    } else {
                        this.pinnedNodes.push({ layer, cIdx });
                        if (!this.activationContexts) this.loadActivationContexts();
                    }
                    this.hoveredNode = null;
                    this.updateHighlights();
                },

                unpinNode(layer, cIdx) {
                    const idx = this.pinnedNodes.findIndex(p => p.layer === layer && p.cIdx === cIdx);
                    if (idx >= 0) this.pinnedNodes.splice(idx, 1);
                    this.updateHighlights();
                },

                isNodePinned(layer, cIdx) {
                    return this.pinnedNodes.some(p => p.layer === layer && p.cIdx === cIdx);
                },

                updateHighlights() {
                    const svg = this.$refs.graph;
                    if (!svg) return;

                    svg.querySelectorAll('.edge').forEach(el => el.classList.remove('highlighted'));
                    svg.querySelectorAll('.node').forEach(el => el.classList.remove('same-component'));

                    // Collect all highlighted component keys
                    const highlightedKeys = new Set();

                    // From pinned nodes
                    for (const pinned of this.pinnedNodes) {
                        svg.querySelectorAll('.node').forEach(el => {
                            if (el.getAttribute('data-layer') === pinned.layer &&
                                el.getAttribute('data-cidx') === String(pinned.cIdx)) {
                                const seq = el.getAttribute('data-seq');
                                highlightedKeys.add(`${pinned.layer}:${seq}:${pinned.cIdx}`);
                            }
                        });
                    }

                    // From hovered node (if not pinned)
                    if (this.hoveredNode && !this.isNodePinned(this.hoveredNode.layer, this.hoveredNode.cIdx)) {
                        svg.querySelectorAll('.node').forEach(el => {
                            if (el.getAttribute('data-layer') === this.hoveredNode.layer &&
                                el.getAttribute('data-cidx') === String(this.hoveredNode.cIdx)) {
                                const seq = el.getAttribute('data-seq');
                                highlightedKeys.add(`${this.hoveredNode.layer}:${seq}:${this.hoveredNode.cIdx}`);
                            }
                        });
                    }

                    // Apply highlights
                    svg.querySelectorAll('.edge').forEach(el => {
                        const src = el.getAttribute('data-src');
                        const tgt = el.getAttribute('data-tgt');
                        if (highlightedKeys.has(src) || highlightedKeys.has(tgt)) {
                            el.classList.add('highlighted');
                        }
                    });

                    svg.querySelectorAll('.node').forEach(el => {
                        const key = `${el.getAttribute('data-layer')}:${el.getAttribute('data-seq')}:${el.getAttribute('data-cidx')}`;
                        if (highlightedKeys.has(key)) {
                            el.classList.add('same-component');
                        }
                    });
                },

                async searchPrompts() {
                    if (this.pinnedNodes.length === 0) return;

                    timeStart('search.total');
                    const components = this.pinnedNodes.map(p => `${p.layer}:${p.cIdx}`).join(',');

                    timeStart('search.fetch');
                    const result = await fetch(`${this.apiBase}/api/search?components=${encodeURIComponent(components)}&mode=all`).then(r => r.json());
                    timeEnd('search.fetch');

                    this.searchResults = result.results;
                    timeEnd('search.total');
                    console.log(`[timing] search found ${result.results.length} results`);
                },

                buildComponentHtml(layer, cIdx) {
                    const actCtx = this.activationContexts?.[layer];
                    const subcomp = actCtx?.find(s => s.subcomponent_idx === cIdx);

                    if (!subcomp) {
                        return `<p style="color: #666;">No activation context data</p>`;
                    }

                    const globalImp = this.componentImportance[`${layer}:${cIdx}`] || 0;
                    let sumAbsAttr = 0, countEdges = 0;
                    for (const edge of this.allEdges) {
                        const [srcLayer, , srcCIdx] = edge.srcKey.split(':');
                        const [tgtLayer, , tgtCIdx] = edge.tgtKey.split(':');
                        if ((srcLayer === layer && +srcCIdx === cIdx) || (tgtLayer === layer && +tgtCIdx === cIdx)) {
                            sumAbsAttr += Math.abs(edge.val);
                            countEdges++;
                        }
                    }

                    let html = `<p class="stats"><strong>Mean CI:</strong> ${subcomp.mean_ci.toFixed(4)} | <strong>Edges:</strong> ${countEdges}</p>`;

                    if (subcomp.example_tokens?.length > 0) {
                        html += '<h4>Top Activating Examples</h4>';
                        for (let i = 0; i < Math.min(5, subcomp.example_tokens.length); i++) {
                            const tokens = subcomp.example_tokens[i];
                            const ciVals = subcomp.example_ci[i];
                            const activePos = subcomp.example_active_pos[i];

                            html += `<div class="example-row">`;
                            for (let j = 0; j < tokens.length; j++) {
                                const ci = ciVals[j];
                                const isActive = j === activePos;
                                const bg = `rgba(255, 100, 100, ${Math.min(1, ci * 5)})`;
                                html += `<span class="example-token${isActive ? ' active' : ''}" style="background:${bg}">${this.escapeHtml(tokens[j])}</span>`;
                            }
                            html += `</div>`;
                        }
                    }

                    html += '<div class="tables-row">';
                    if (subcomp.pr_tokens?.length > 0) {
                        html += '<div><h4>Top Input Tokens</h4><table class="pr-table"><tr><th>Token</th><th>P(fire|tok)</th></tr>';
                        for (let i = 0; i < Math.min(5, subcomp.pr_tokens.length); i++) {
                            html += `<tr><td><code>${this.escapeHtml(subcomp.pr_tokens[i])}</code></td><td>${subcomp.pr_precisions[i].toFixed(3)}</td></tr>`;
                        }
                        html += '</table></div>';
                    }
                    if (subcomp.predicted_tokens?.length > 0) {
                        html += '<div><h4>Top Predicted</h4><table class="pr-table"><tr><th>Token</th><th>P</th></tr>';
                        for (let i = 0; i < Math.min(5, subcomp.predicted_tokens.length); i++) {
                            html += `<tr><td><code>${this.escapeHtml(subcomp.predicted_tokens[i])}</code></td><td>${subcomp.predicted_probs[i].toFixed(3)}</td></tr>`;
                        }
                        html += '</table></div>';
                    }
                    html += '</div>';

                    return html;
                },

                escapeHtml(text) {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                }
            };
        }
    </script>
</body>
</html>
