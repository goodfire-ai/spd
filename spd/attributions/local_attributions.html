<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Attributions Graph</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #fafafa;
            display: flex;
            height: 100vh;
        }
        /* Sidebar styles */
        .sidebar {
            width: 280px;
            background: #fff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
            background: #f5f5f5;
        }
        .sidebar-header h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; }
        .search-btn {
            width: 100%;
            padding: 0.5rem;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .search-btn:hover { background: #1976d2; }
        .search-btn:disabled { background: #ccc; cursor: not-allowed; }
        .search-info {
            padding: 0.5rem 1rem;
            background: #e3f2fd;
            font-size: 0.8rem;
            color: #1565c0;
        }
        .search-results {
            flex: 1;
            overflow-y: auto;
        }
        .search-result {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.15s;
        }
        .search-result:hover { background: #f5f5f5; }
        .search-result.active { background: #e3f2fd; border-left: 3px solid #2196f3; }
        .search-result-id { font-size: 0.75rem; color: #666; margin-bottom: 0.25rem; }
        .search-result-preview {
            font-family: monospace;
            font-size: 0.8rem;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* Main content */
        .main-content {
            flex: 1;
            padding: 1rem;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }
        h1 { margin-top: 0; font-size: 1.5rem; }
        .controls {
            display: flex;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-wrap: wrap;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .controls input[type="range"] { width: 450px; }
        .controls input[type="number"] {
            width: 80px;
            padding: 0.25rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .controls select {
            padding: 0.25rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }
        .edge-count { color: #666; font-size: 0.9rem; }
        .db-info { color: #666; font-size: 0.85rem; margin-left: auto; }
        .graph-wrapper {
            display: flex;
            max-height: 70vh;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .layer-labels-container {
            position: sticky;
            left: 0;
            background: white;
            border-right: 1px solid #eee;
            z-index: 11;
            flex-shrink: 0;
        }
        .graph-container {
            overflow: auto;
            flex: 1;
            position: relative;
        }
        .token-labels-container {
            position: sticky;
            bottom: 0;
            background: white;
            border-top: 1px solid #eee;
            z-index: 10;
        }
        svg { display: block; }
        .legend {
            margin-top: 1rem;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .legend h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; }
        .legend-items { display: flex; flex-wrap: wrap; gap: 1rem; }
        .legend-item { display: flex; align-items: center; gap: 0.25rem; font-size: 0.85rem; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        .legend-edge { margin-top: 0.5rem; font-size: 0.85rem; display: flex; align-items: center; gap: 1rem; }
        .edge-pos, .edge-neg { display: inline-block; width: 30px; height: 3px; margin-right: 0.25rem; }
        .edge-pos { background: #2196f3; }
        .edge-neg { background: #f44336; }
        #loading { padding: 2rem; text-align: center; color: #666; }
        .node-details {
            position: fixed;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            max-width: 1000px;
            max-height: 800px;
            overflow-y: auto;
            z-index: 1000;
            pointer-events: auto;
        }
        .node-details.pinned-mode {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            overflow-x: auto;
            max-width: calc(100vw - 40px);
        }
        .node-details.pinned-mode #node-examples {
            display: flex;
            flex-direction: row;
            gap: 1rem;
        }
        .node-details.pinned-mode #node-examples > div {
            flex-shrink: 0;
            min-width: 350px;
            max-width: 500px;
        }
        .pinned-container {
            margin-top: 1rem;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .pinned-container h3 {
            margin: 0 0 0.75rem 0;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #pinned-items {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }
        #pinned-items > div {
            flex-shrink: 0;
            min-width: 350px;
            max-width: 500px;
        }
        .edge {
            transition: opacity 0.15s, stroke-width 0.15s;
        }
        .edge.highlighted {
            opacity: 1 !important;
            stroke-width: 3 !important;
        }
        .node {
            transition: stroke-width 0.15s, filter 0.15s;
        }
        .node.same-component {
            stroke: #000 !important;
            stroke-width: 2.5 !important;
            filter: brightness(0.7) saturate(1.5);
            opacity: 1 !important;
        }
        .node-details h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; }
        #node-info { margin-bottom: 0.5rem; font-size: 0.85rem; }
        #node-info p { margin: 0.15rem 0; }
        .example-row {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin: 0.5rem 0;
            font-family: monospace;
            font-size: 0.85rem;
        }
        .example-token {
            padding: 2px 4px;
            border-radius: 2px;
        }
        .example-token.active {
            font-weight: bold;
            border: 1px solid #333;
        }
        .pr-table { font-size: 0.85rem; margin-top: 0.5rem; }
        .pr-table th, .pr-table td { padding: 0.25rem 0.5rem; text-align: left; }
    </style>
</head>
<body>
    <!-- Sidebar for search -->
    <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <h3>Search Prompts</h3>
            <button id="search-btn" class="search-btn" disabled>
                Find prompts with pinned components
            </button>
        </div>
        <div id="search-info" class="search-info" style="display:none;"></div>
        <div id="search-results" class="search-results"></div>
    </div>

    <!-- Main content -->
    <div class="main-content">
        <h1>Local Attributions Graph</h1>
        <div id="loading">Loading data...</div>
        <div id="app" style="display:none;">
            <div class="controls">
                <label id="prompt-selector-container">
                    Prompt:
                    <select id="prompt-selector"></select>
                </label>
                <label>
                    Max mean CI:
                    <input type="number" id="max-mean-ci" min="0" max="1" step="0.01" value="0.5">
                </label>
                <label>
                    Top K edges:
                    <input type="number" id="topk-edges" min="10" max="10000" step="100" value="1000">
                </label>
                <span class="edge-count">Showing <span id="edge-count">0</span> edges</span>
                <span id="db-info" class="db-info"></span>
            </div>
            <div class="graph-wrapper">
                <div id="layer-labels" class="layer-labels-container"></div>
                <div class="graph-container">
                    <svg id="graph"></svg>
                    <div id="token-labels" class="token-labels-container"></div>
                </div>
            </div>
            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-items" id="legend-items"></div>
                <div class="legend-edge">
                    <span class="edge-pos"></span> Positive
                    <span class="edge-neg"></span> Negative
                </div>
            </div>

            <div id="pinned-container" class="pinned-container" style="display:none;">
                <h3>
                    <span>Pinned Components</span>
                    <button id="clear-pinned" style="font-size: 0.8rem; padding: 0.25rem 0.5rem; cursor: pointer;">Clear all</button>
                </h3>
                <div id="pinned-items"></div>
            </div>

            <div id="node-details" class="node-details" style="display:none;">
                <h3>Component Details</h3>
                <div id="node-info"></div>
                <div id="node-examples"></div>
            </div>
        </div>
    </div>

    <script>
        const COMPONENT_SIZE = 8;
        const COMPONENT_GAP = 2;
        const LAYER_GAP = 30;
        const MARGIN = { top: 60, right: 40, bottom: 20, left: 20 };
        const LABEL_WIDTH = 100;

        const SUBTYPE_ORDER = ['q_proj', 'k_proj', 'v_proj', 'o_proj', 'c_fc', 'down_proj'];
        const COLORS = {
            q_proj: "#e91e63", k_proj: "#9c27b0", v_proj: "#673ab7",
            o_proj: "#3f51b5", c_fc: "#009688", down_proj: "#4caf50"
        };

        // API base URL (use current origin when served, fallback for development)
        let apiBase = window.location.origin || 'http://localhost:8765';

        // Data state
        let data = null;              // Current prompt data (tokens, pairs)
        let activationContexts = null; // Shared across prompts
        let allPrompts = [];          // List of all prompts
        let currentPromptId = null;   // Current prompt ID
        let searchResults = [];       // Current search results

        let maxAttr = 1;
        let allEdges = [];
        let componentImportance = {};
        let componentImportanceLocal = {};
        let componentMeanCI = {};
        let layerYPositions = {};
        let nodePositions = {};
        let nodeOutAttr = {};
        let hoveredNodeKey = null;
        let isHoveringTooltip = false;
        let pinnedNodes = [];  // [{ layer, cIdx }, ...] - persists across prompt switches

        function parseLayer(name) {
            const m = name.match(/h\.(\d+)\.(attn|mlp)\.(\w+)/);
            return m ? { name, block: +m[1], type: m[2], subtype: m[3] } : null;
        }

        // =====================================================================
        // Load data from server
        // =====================================================================

        let activationContextsLoading = false;
        let activationContextsCallbacks = [];

        function loadData() {
            // Load meta and first prompt immediately - don't wait for full prompts list
            fetch(`${apiBase}/api/meta`)
                .then(r => r.json())
                .then(meta => {
                    document.getElementById('db-info').textContent = `DB: ${meta.prompt_count} prompts`;

                    // Load first prompt immediately
                    if (meta.prompt_count > 0) {
                        loadPrompt(1);  // First prompt ID is typically 1
                    } else {
                        document.getElementById('loading').textContent = 'No prompts in database';
                    }

                    // Load prompts list in background for the selector
                    fetch(`${apiBase}/api/prompts`).then(r => r.json()).then(prompts => {
                        allPrompts = prompts;
                        const selector = document.getElementById('prompt-selector');
                        selector.innerHTML = prompts.map(p =>
                            `<option value="${p.id}">${p.id}: ${p.preview}</option>`
                        ).join('');
                        // Update selector to current prompt
                        if (currentPromptId) {
                            selector.value = currentPromptId;
                        }
                    });
                })
                .catch(e => {
                    document.getElementById('loading').textContent =
                        'Error connecting to database server. Make sure the server is running:\n' +
                        'python -m spd.attributions.serve --db_path <path> --port 8765';
                    console.error(e);
                });
        }

        function getActivationContexts(callback) {
            // Lazy-load activation contexts only when needed
            if (activationContexts) {
                callback(activationContexts);
                return;
            }

            activationContextsCallbacks.push(callback);

            if (activationContextsLoading) return;
            activationContextsLoading = true;

            fetch(`${apiBase}/api/activation_contexts`)
                .then(r => r.json())
                .then(actCtx => {
                    activationContexts = actCtx;
                    // Call all waiting callbacks
                    for (const cb of activationContextsCallbacks) {
                        cb(activationContexts);
                    }
                    activationContextsCallbacks = [];
                })
                .catch(e => {
                    console.error('Error loading activation contexts:', e);
                    activationContextsLoading = false;
                });
        }

        function loadPrompt(promptId) {
            currentPromptId = promptId;
            fetch(`${apiBase}/api/prompt/${promptId}`)
                .then(r => r.json())
                .then(promptData => {
                    data = {
                        tokens: promptData.tokens,
                        pairs: promptData.pairs,
                    };
                    initializeWithData();

                    // Update selector
                    document.getElementById('prompt-selector').value = promptId;

                    // Update search result highlighting
                    document.querySelectorAll('.search-result').forEach(el => {
                        el.classList.toggle('active', el.dataset.id === String(promptId));
                    });

                    // Load activation contexts in background for CI filtering and tooltips
                    if (!activationContexts) {
                        getActivationContexts(actCtx => {
                            updateMeanCILookup(actCtx);
                            render();  // Re-render with CI filtering
                        });
                    }
                })
                .catch(e => {
                    console.error('Error loading prompt:', e);
                });
        }

        document.getElementById('prompt-selector').addEventListener('change', (e) => {
            loadPrompt(parseInt(e.target.value));
        });

        // =====================================================================
        // Search functionality
        // =====================================================================

        document.getElementById('search-btn').addEventListener('click', searchPrompts);

        function updateSearchButton() {
            const btn = document.getElementById('search-btn');
            btn.disabled = pinnedNodes.length === 0;
            btn.textContent = pinnedNodes.length === 0
                ? 'Pin components to search'
                : `Find prompts with ${pinnedNodes.length} pinned component${pinnedNodes.length > 1 ? 's' : ''}`;
        }

        function searchPrompts() {
            if (pinnedNodes.length === 0) return;

            const components = pinnedNodes.map(p => `${p.layer}:${p.cIdx}`).join(',');
            fetch(`${apiBase}/api/search?components=${encodeURIComponent(components)}&mode=all`)
                .then(r => r.json())
                .then(result => {
                    searchResults = result.results;
                    renderSearchResults(result);
                })
                .catch(e => {
                    console.error('Search error:', e);
                });
        }

        function renderSearchResults(result) {
            const infoEl = document.getElementById('search-info');
            const resultsEl = document.getElementById('search-results');

            infoEl.textContent = `Found ${result.count} prompt${result.count !== 1 ? 's' : ''} with all ${result.query.components.length} components`;
            infoEl.style.display = 'block';

            resultsEl.innerHTML = result.results.map(p => `
                <div class="search-result ${p.id === currentPromptId ? 'active' : ''}"
                     data-id="${p.id}"
                     onclick="loadPrompt(${p.id})">
                    <div class="search-result-id">Prompt #${p.id}</div>
                    <div class="search-result-preview">${escapeHtml(p.preview)}</div>
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // =====================================================================
        // Core visualization (shared between modes)
        // =====================================================================

        function updateMeanCILookup(actCtx) {
            // Build mean CI lookup from activation contexts
            componentMeanCI = {};
            if (actCtx) {
                for (const [layer, subcomps] of Object.entries(actCtx)) {
                    for (const subcomp of subcomps) {
                        componentMeanCI[`${layer}:${subcomp.subcomponent_idx}`] = subcomp.mean_ci;
                    }
                }
            }
        }

        function initializeWithData() {
            // Find max attribution
            maxAttr = 1;
            for (const pair of data.pairs) {
                const isCrossSeq = pair.is_cross_seq;
                for (const entry of pair.attribution) {
                    const val = isCrossSeq ? entry[4] : entry[3];
                    if (Math.abs(val) > maxAttr) maxAttr = Math.abs(val);
                }
            }

            computeComponentImportanceAndEdges();

            // Update mean CI lookup if activation contexts already loaded
            if (activationContexts) {
                updateMeanCILookup(activationContexts);
            }

            computeNodeOutAttrs();
            maxNodeOutAttr = Math.max(...Object.values(nodeOutAttr), 1);

            // Build legend (only once)
            const legendEl = document.getElementById('legend-items');
            if (legendEl.children.length === 0) {
                for (const [name, color] of Object.entries(COLORS)) {
                    legendEl.innerHTML += `<div class="legend-item"><span class="legend-dot" style="background:${color}"></span>${name}</div>`;
                }
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('app').style.display = 'block';

            render();
            updatePinnedDisplay();
            updateSearchButton();
        }

        function computeComponentImportanceAndEdges() {
            componentImportance = {};
            componentImportanceLocal = {};
            allEdges = [];

            for (const pair of data.pairs) {
                const isCrossSeq = pair.is_cross_seq;
                const cInIdxs = pair.trimmed_c_in_idxs;
                const cOutIdxs = pair.trimmed_c_out_idxs;

                for (const entry of pair.attribution) {
                    let sIn, cInLocal, sOut, cOutLocal, val;
                    if (isCrossSeq) {
                        [sIn, cInLocal, sOut, cOutLocal, val] = entry;
                    } else {
                        sIn = entry[0];
                        sOut = entry[0];
                        cInLocal = entry[1];
                        cOutLocal = entry[2];
                        val = entry[3];
                    }

                    const cInIdx = cInIdxs[cInLocal];
                    const cOutIdx = cOutIdxs[cOutLocal];

                    allEdges.push({
                        srcKey: `${pair.source}:${sIn}:${cInIdx}`,
                        tgtKey: `${pair.target}:${sOut}:${cOutIdx}`,
                        val
                    });

                    const valSq = val * val;

                    const srcKey = `${pair.source}:${cInIdx}`;
                    if (!componentImportance[srcKey]) componentImportance[srcKey] = 0;
                    componentImportance[srcKey] += valSq;

                    const tgtKey = `${pair.target}:${cOutIdx}`;
                    if (!componentImportance[tgtKey]) componentImportance[tgtKey] = 0;
                    componentImportance[tgtKey] += valSq;

                    const srcKeyLocal = `${pair.source}:${sIn}:${cInIdx}`;
                    if (!componentImportanceLocal[srcKeyLocal]) componentImportanceLocal[srcKeyLocal] = 0;
                    componentImportanceLocal[srcKeyLocal] += valSq;

                    const tgtKeyLocal = `${pair.target}:${sOut}:${cOutIdx}`;
                    if (!componentImportanceLocal[tgtKeyLocal]) componentImportanceLocal[tgtKeyLocal] = 0;
                    componentImportanceLocal[tgtKeyLocal] += valSq;
                }
            }

            allEdges.sort((a, b) => Math.abs(b.val) - Math.abs(a.val));
        }

        function getFilteredEdgesAndNodes(topK, maxMeanCI) {
            const ciFilteredEdges = allEdges.filter(edge => {
                const [srcLayer, , srcCIdx] = edge.srcKey.split(':');
                const [tgtLayer, , tgtCIdx] = edge.tgtKey.split(':');
                const srcMeanCI = componentMeanCI[`${srcLayer}:${srcCIdx}`];
                const tgtMeanCI = componentMeanCI[`${tgtLayer}:${tgtCIdx}`];
                const srcOk = srcMeanCI === undefined || srcMeanCI <= maxMeanCI;
                const tgtOk = tgtMeanCI === undefined || tgtMeanCI <= maxMeanCI;
                return srcOk && tgtOk;
            });

            const topEdges = ciFilteredEdges.slice(0, topK);

            const activeNodes = new Set();
            for (const edge of topEdges) {
                activeNodes.add(edge.srcKey);
                activeNodes.add(edge.tgtKey);
            }

            return { edges: topEdges, activeNodes };
        }

        function buildLayout(activeNodes) {
            const nodesPerLayerSeq = {};
            const allLayers = new Set();

            for (const nodeKey of activeNodes) {
                const [layer, seqIdx, cIdx] = nodeKey.split(':');
                allLayers.add(layer);
                const key = `${layer}:${seqIdx}`;
                if (!nodesPerLayerSeq[key]) nodesPerLayerSeq[key] = [];
                nodesPerLayerSeq[key].push(+cIdx);
            }

            const layers = Array.from(allLayers).sort((a, b) => {
                const infoA = parseLayer(a);
                const infoB = parseLayer(b);
                if (infoA.block !== infoB.block) {
                    return infoA.block - infoB.block;
                }
                return SUBTYPE_ORDER.indexOf(infoA.subtype) - SUBTYPE_ORDER.indexOf(infoB.subtype);
            });

            layerYPositions = {};
            let currentY = MARGIN.top;
            for (const layer of layers.slice().reverse()) {
                layerYPositions[layer] = currentY;
                currentY += COMPONENT_SIZE + LAYER_GAP;
            }

            const maxComponentsPerSeq = [];
            for (let seqIdx = 0; seqIdx < data.tokens.length; seqIdx++) {
                let maxAtSeq = 0;
                for (const layer of layers) {
                    const key = `${layer}:${seqIdx}`;
                    const count = nodesPerLayerSeq[key]?.length || 0;
                    maxAtSeq = Math.max(maxAtSeq, count);
                }
                maxComponentsPerSeq.push(maxAtSeq);
            }

            const MIN_COL_WIDTH = 30;
            const COL_PADDING = 16;
            const seqWidths = maxComponentsPerSeq.map(n =>
                Math.max(MIN_COL_WIDTH, n * (COMPONENT_SIZE + COMPONENT_GAP) + COL_PADDING * 2)
            );
            const seqXStarts = [MARGIN.left];
            for (let i = 0; i < seqWidths.length - 1; i++) {
                seqXStarts.push(seqXStarts[i] + seqWidths[i]);
            }

            nodePositions = {};

            for (const layer of layers) {
                for (let seqIdx = 0; seqIdx < data.tokens.length; seqIdx++) {
                    const key = `${layer}:${seqIdx}`;
                    const components = nodesPerLayerSeq[key] || [];

                    components.sort((a, b) => {
                        const impA = componentImportanceLocal[`${layer}:${seqIdx}:${a}`] || 0;
                        const impB = componentImportanceLocal[`${layer}:${seqIdx}:${b}`] || 0;
                        return impB - impA;
                    });

                    const baseX = seqXStarts[seqIdx] + COL_PADDING;
                    const baseY = layerYPositions[layer];

                    for (let i = 0; i < components.length; i++) {
                        const cIdx = components[i];
                        const nodeKey = `${layer}:${seqIdx}:${cIdx}`;
                        nodePositions[nodeKey] = {
                            x: baseX + i * (COMPONENT_SIZE + COMPONENT_GAP) + COMPONENT_SIZE / 2,
                            y: baseY + COMPONENT_SIZE / 2
                        };
                    }
                }
            }

            return { layers, seqWidths, seqXStarts };
        }

        function computeNodeOutAttrs() {
            nodeOutAttr = {};
            for (const pair of data.pairs) {
                const isCrossSeq = pair.is_cross_seq;
                const cInIdxs = pair.trimmed_c_in_idxs;

                for (const entry of pair.attribution) {
                    let sIn, cInLocal, val;
                    if (isCrossSeq) {
                        sIn = entry[0];
                        cInLocal = entry[1];
                        val = entry[4];
                    } else {
                        sIn = entry[0];
                        cInLocal = entry[1];
                        val = entry[3];
                    }

                    const cIdx = cInIdxs[cInLocal];
                    const key = `${pair.source}:${sIn}:${cIdx}`;
                    if (!nodeOutAttr[key]) nodeOutAttr[key] = 0;
                    nodeOutAttr[key] += Math.abs(val);
                }
            }
        }

        let maxNodeOutAttr = 1;

        function hideNodeDetails() {
            setTimeout(() => {
                if (!isHoveringTooltip && !hoveredNodeKey) {
                    document.getElementById('node-details').style.display = 'none';
                    if (pinnedNodes.length === 0) {
                        unhighlightAll();
                    }
                }
            }, 100);
        }

        function pinNode(layer, cIdx, nodeKey) {
            const existingIdx = pinnedNodes.findIndex(p => p.layer === layer && p.cIdx === cIdx);

            if (existingIdx >= 0) {
                pinnedNodes.splice(existingIdx, 1);
            } else {
                pinnedNodes.push({ layer, cIdx, nodeKey });
            }

            updatePinnedDisplay();
            updateSearchButton();
        }

        document.getElementById('clear-pinned').addEventListener('click', () => {
            pinnedNodes = [];
            updatePinnedDisplay();
            updateSearchButton();
        });

        function updatePinnedDisplay() {
            if (pinnedNodes.length === 0) {
                document.getElementById('pinned-container').style.display = 'none';
                unhighlightAll();
                return;
            }

            const svg = document.getElementById('graph');

            svg.querySelectorAll('.edge').forEach(el => el.classList.remove('highlighted'));
            svg.querySelectorAll('.node').forEach(el => el.classList.remove('same-component'));

            const allPinnedComponentKeys = new Set();
            for (const pinned of pinnedNodes) {
                svg.querySelectorAll('.node').forEach(el => {
                    const nodeLayer = el.getAttribute('data-layer');
                    const nodeCIdx = el.getAttribute('data-cidx');
                    const nodeSeq = el.getAttribute('data-seq');
                    if (nodeLayer === pinned.layer && nodeCIdx === String(pinned.cIdx)) {
                        allPinnedComponentKeys.add(`${nodeLayer}:${nodeSeq}:${nodeCIdx}`);
                    }
                });
            }

            svg.querySelectorAll('.edge').forEach(el => {
                const src = el.getAttribute('data-src');
                const tgt = el.getAttribute('data-tgt');
                if (allPinnedComponentKeys.has(src) || allPinnedComponentKeys.has(tgt)) {
                    el.classList.add('highlighted');
                }
            });

            svg.querySelectorAll('.node').forEach(el => {
                const nodeLayer = el.getAttribute('data-layer');
                const nodeCIdx = el.getAttribute('data-cidx');
                const nodeSeq = el.getAttribute('data-seq');
                const nodeKey = `${nodeLayer}:${nodeSeq}:${nodeCIdx}`;
                if (allPinnedComponentKeys.has(nodeKey)) {
                    el.classList.add('same-component');
                }
            });

            showPinnedDetails();
        }

        function showPinnedDetails() {
            const containerEl = document.getElementById('pinned-container');
            const itemsEl = document.getElementById('pinned-items');

            // If activation contexts not loaded, show loading and fetch
            if (!activationContexts) {
                itemsEl.innerHTML = '<p>Loading component details...</p>';
                containerEl.style.display = 'block';
                getActivationContexts(actCtx => {
                    updateMeanCILookup(actCtx);
                    showPinnedDetails();  // Re-render with loaded data
                });
                return;
            }

            let html = '';
            for (const pinned of pinnedNodes) {
                html += buildFullNodeDetailsHtml(pinned.layer, pinned.cIdx);
            }

            itemsEl.innerHTML = html;
            containerEl.style.display = 'block';
        }

        function buildFullNodeDetailsHtml(layer, cIdx) {
            const globalImp = componentImportance[`${layer}:${cIdx}`] || 0;
            let sumAbsAttr = 0;
            let countEdges = 0;
            for (const edge of allEdges) {
                const [srcLayer, , srcCIdx] = edge.srcKey.split(':');
                const [tgtLayer, , tgtCIdx] = edge.tgtKey.split(':');
                if ((srcLayer === layer && +srcCIdx === cIdx) || (tgtLayer === layer && +tgtCIdx === cIdx)) {
                    sumAbsAttr += Math.abs(edge.val);
                    countEdges++;
                }
            }
            const meanAbsAttr = countEdges > 0 ? sumAbsAttr / countEdges : 0;
            const meanSqAttr = countEdges > 0 ? globalImp / countEdges : 0;

            const actCtx = activationContexts?.[layer];
            const subcomp = actCtx?.find(s => s.subcomponent_idx === cIdx);

            let html = `<div style="border: 1px solid #ddd; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; background: #fafafa;">`;
            html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                <strong style="font-size: 1rem;">${layer} : ${cIdx}</strong>
                <button onclick="pinNode('${layer}', ${cIdx}, '')" style="cursor: pointer; background: #f44336; color: white; border: none; border-radius: 4px; padding: 0.25rem 0.5rem;">✕ unpin</button>
            </div>`;

            if (subcomp) {
                html += `<p style="margin: 0.25rem 0; font-size: 0.85rem;"><strong>Mean CI:</strong> ${subcomp.mean_ci.toFixed(4)} | <strong>Sum attr²:</strong> ${globalImp.toFixed(6)} | <strong>Mean |attr|:</strong> ${meanAbsAttr.toFixed(6)} | <strong>Mean attr²:</strong> ${meanSqAttr.toFixed(6)} <small>(${countEdges} edges)</small></p>`;

                if (subcomp.example_tokens && subcomp.example_tokens.length > 0) {
                    html += '<h4 style="margin: 0.75rem 0 0.25rem 0; font-size: 0.85rem;">Top Activating Examples</h4>';
                    for (let i = 0; i < subcomp.example_tokens.length; i++) {
                        const tokens = subcomp.example_tokens[i];
                        const ciVals = subcomp.example_ci[i];
                        const activePos = subcomp.example_active_pos[i];
                        const activeCi = subcomp.example_active_ci[i];

                        html += `<div class="example-row">`;
                        for (let j = 0; j < tokens.length; j++) {
                            const ci = ciVals[j];
                            const isActive = j === activePos;
                            const bg = `rgba(255, 100, 100, ${Math.min(1, ci * 5)})`;
                            html += `<span class="example-token${isActive ? ' active' : ''}" style="background:${bg}" title="CI: ${ci.toFixed(3)}">${escapeHtml(tokens[j])}</span>`;
                        }
                        html += ` <small>(CI: ${activeCi.toFixed(3)})</small></div>`;
                    }
                }

                html += '<div style="display: flex; gap: 2rem; flex-wrap: wrap;">';

                if (subcomp.pr_tokens && subcomp.pr_tokens.length > 0) {
                    html += '<div>';
                    html += '<h4 style="margin: 0.75rem 0 0.25rem 0; font-size: 0.85rem;">Top Input Tokens</h4>';
                    html += '<table class="pr-table"><tr><th>Token</th><th title="P(fires | token)">P(fire|tok)</th></tr>';
                    const nShow = Math.min(10, subcomp.pr_tokens.length);
                    for (let i = 0; i < nShow; i++) {
                        html += `<tr><td><code>${escapeHtml(subcomp.pr_tokens[i])}</code></td><td>${subcomp.pr_precisions[i].toFixed(3)}</td></tr>`;
                    }
                    html += '</table></div>';
                }

                if (subcomp.predicted_tokens && subcomp.predicted_tokens.length > 0) {
                    html += '<div>';
                    html += '<h4 style="margin: 0.75rem 0 0.25rem 0; font-size: 0.85rem;">Top Predicted Tokens</h4>';
                    html += '<table class="pr-table"><tr><th>Token</th><th>P(pred|fire)</th></tr>';
                    const nShow = Math.min(10, subcomp.predicted_tokens.length);
                    for (let i = 0; i < nShow; i++) {
                        html += `<tr><td><code>${escapeHtml(subcomp.predicted_tokens[i])}</code></td><td>${subcomp.predicted_probs[i].toFixed(3)}</td></tr>`;
                    }
                    html += '</table></div>';
                }

                html += '</div>';
            } else {
                html += `<p style="color: #666; font-size: 0.85rem;">No activation context data for this component</p>`;
            }

            html += '</div>';
            return html;
        }

        function unhighlightAll() {
            const svg = document.getElementById('graph');
            svg.querySelectorAll('.edge').forEach(el => el.classList.remove('highlighted'));
            svg.querySelectorAll('.node').forEach(el => el.classList.remove('same-component'));
        }

        function highlightForNode(nodeKey, layer, cIdx) {
            const svg = document.getElementById('graph');

            const sameComponentKeys = new Set();
            svg.querySelectorAll('.node').forEach(el => {
                const nodeLayer = el.getAttribute('data-layer');
                const nodeCIdx = el.getAttribute('data-cidx');
                const nodeSeq = el.getAttribute('data-seq');
                if (nodeLayer === layer && nodeCIdx === String(cIdx)) {
                    sameComponentKeys.add(`${nodeLayer}:${nodeSeq}:${nodeCIdx}`);
                }
            });

            svg.querySelectorAll('.edge').forEach(el => {
                const src = el.getAttribute('data-src');
                const tgt = el.getAttribute('data-tgt');
                if (sameComponentKeys.has(src) || sameComponentKeys.has(tgt)) {
                    el.classList.add('highlighted');
                } else {
                    el.classList.remove('highlighted');
                }
            });

            svg.querySelectorAll('.node').forEach(el => {
                const nodeLayer = el.getAttribute('data-layer');
                const nodeCIdx = el.getAttribute('data-cidx');
                if (nodeLayer === layer && nodeCIdx === String(cIdx)) {
                    el.classList.add('same-component');
                } else {
                    el.classList.remove('same-component');
                }
            });
        }

        function showNodeDetails(layer, cIdx, mouseX, mouseY) {
            const detailsEl = document.getElementById('node-details');
            const infoEl = document.getElementById('node-info');
            const examplesEl = document.getElementById('node-examples');

            detailsEl.classList.remove('pinned-mode');
            detailsEl.style.position = 'fixed';
            detailsEl.style.bottom = '';
            detailsEl.style.maxHeight = '800px';
            detailsEl.style.maxWidth = '1000px';

            const padding = 15;
            let left = mouseX + padding;
            let top = mouseY + padding;

            if (left + 1000 > window.innerWidth) {
                left = mouseX - 1000 - padding;
            }
            if (top + 800 > window.innerHeight) {
                top = mouseY - 800 - padding;
            }

            detailsEl.style.left = left + 'px';
            detailsEl.style.top = top + 'px';

            // If activation contexts not loaded, show loading and fetch
            if (!activationContexts) {
                infoEl.innerHTML = `<p><strong>${layer} : ${cIdx}</strong></p><p>Loading details...</p>`;
                examplesEl.innerHTML = '';
                detailsEl.style.display = 'block';
                getActivationContexts(actCtx => {
                    updateMeanCILookup(actCtx);
                    // Re-show if still hovering this node
                    if (hoveredNodeKey && hoveredNodeKey.startsWith(`${layer}:`) && hoveredNodeKey.endsWith(`:${cIdx}`)) {
                        showNodeDetails(layer, cIdx, mouseX, mouseY);
                    }
                });
                return;
            }

            const actCtx = activationContexts?.[layer];
            if (!actCtx) {
                infoEl.innerHTML = `<p>No activation context data for ${layer}</p>`;
                examplesEl.innerHTML = '';
                detailsEl.style.display = 'block';
                return;
            }

            const subcomp = actCtx.find(s => s.subcomponent_idx === cIdx);
            if (!subcomp) {
                infoEl.innerHTML = `<p>No data for component ${cIdx} in ${layer}</p>`;
                examplesEl.innerHTML = '';
                detailsEl.style.display = 'block';
                return;
            }

            const globalImp = componentImportance[`${layer}:${cIdx}`] || 0;
            let sumAbsAttr = 0;
            let countEdges = 0;
            for (const edge of allEdges) {
                const [srcLayer, , srcCIdx] = edge.srcKey.split(':');
                const [tgtLayer, , tgtCIdx] = edge.tgtKey.split(':');
                if ((srcLayer === layer && +srcCIdx === cIdx) || (tgtLayer === layer && +tgtCIdx === cIdx)) {
                    sumAbsAttr += Math.abs(edge.val);
                    countEdges++;
                }
            }
            const meanAbsAttr = countEdges > 0 ? sumAbsAttr / countEdges : 0;
            const meanSqAttr = countEdges > 0 ? globalImp / countEdges : 0;

            infoEl.innerHTML = `
                <p><strong>Layer:</strong> ${layer}</p>
                <p><strong>Component:</strong> ${cIdx}</p>
                <p><strong>Mean CI:</strong> ${subcomp.mean_ci.toFixed(4)}</p>
                <p><strong>Sum attr²:</strong> ${globalImp.toFixed(6)}</p>
                <p><strong>Mean |attr|:</strong> ${meanAbsAttr.toFixed(6)} <small>(${countEdges} edges)</small></p>
                <p><strong>Mean attr²:</strong> ${meanSqAttr.toFixed(6)}</p>
            `;

            let examplesHtml = '<h4>Top Activating Examples</h4>';
            for (let i = 0; i < subcomp.example_tokens.length; i++) {
                const tokens = subcomp.example_tokens[i];
                const ciVals = subcomp.example_ci[i];
                const activePos = subcomp.example_active_pos[i];
                const activeCi = subcomp.example_active_ci[i];

                examplesHtml += `<div class="example-row">`;
                for (let j = 0; j < tokens.length; j++) {
                    const ci = ciVals[j];
                    const isActive = j === activePos;
                    const bg = `rgba(255, 100, 100, ${Math.min(1, ci * 5)})`;
                    examplesHtml += `<span class="example-token${isActive ? ' active' : ''}" style="background:${bg}" title="CI: ${ci.toFixed(3)}">${escapeHtml(tokens[j])}</span>`;
                }
                examplesHtml += ` <small>(CI: ${activeCi.toFixed(3)})</small></div>`;
            }

            if (subcomp.pr_tokens && subcomp.pr_tokens.length > 0) {
                examplesHtml += '<h4>Top Input Tokens</h4>';
                examplesHtml += '<table class="pr-table"><tr><th>Token</th><th title="P(fires | token)">P(fire|tok)</th></tr>';
                const nShow = Math.min(10, subcomp.pr_tokens.length);
                for (let i = 0; i < nShow; i++) {
                    examplesHtml += `<tr><td><code>${escapeHtml(subcomp.pr_tokens[i])}</code></td><td>${subcomp.pr_precisions[i].toFixed(3)}</td></tr>`;
                }
                examplesHtml += '</table>';
            }

            if (subcomp.predicted_tokens && subcomp.predicted_tokens.length > 0) {
                examplesHtml += '<h4>Top Predicted Tokens</h4>';
                examplesHtml += '<p style="font-size:0.8rem;color:#666;margin:0 0 0.5rem 0;">P(token predicted | component fires)</p>';
                examplesHtml += '<table class="pr-table"><tr><th>Token</th><th>Probability</th></tr>';
                const nShow = Math.min(10, subcomp.predicted_tokens.length);
                for (let i = 0; i < nShow; i++) {
                    examplesHtml += `<tr><td><code>${escapeHtml(subcomp.predicted_tokens[i])}</code></td><td>${subcomp.predicted_probs[i].toFixed(3)}</td></tr>`;
                }
                examplesHtml += '</table>';
            }

            examplesEl.innerHTML = examplesHtml;
            detailsEl.style.display = 'block';
        }

        function render() {
            const topK = +document.getElementById('topk-edges').value;
            const maxMeanCI = +document.getElementById('max-mean-ci').value;

            const { edges, activeNodes } = getFilteredEdgesAndNodes(topK, maxMeanCI);
            document.getElementById('edge-count').textContent = edges.length;

            const { layers, seqWidths, seqXStarts } = buildLayout(activeNodes);

            const totalSeqWidth = seqXStarts[seqXStarts.length - 1] + seqWidths[seqWidths.length - 1];
            const width = totalSeqWidth + MARGIN.right;

            let maxY = 0;
            for (const layer in layerYPositions) {
                maxY = Math.max(maxY, layerYPositions[layer] + COMPONENT_SIZE);
            }
            const height = maxY + MARGIN.bottom;

            const svg = document.getElementById('graph');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);

            let html = '';

            for (const e of edges) {
                const p1 = nodePositions[e.srcKey];
                const p2 = nodePositions[e.tgtKey];
                if (p1 && p2) {
                    const color = e.val > 0 ? '#2196f3' : '#f44336';
                    const w = Math.max(0.5, (Math.abs(e.val) / maxAttr) * 2);
                    const op = 0.05 + (Math.abs(e.val) / maxAttr) * 0.95;
                    html += `<line class="edge" data-src="${e.srcKey}" data-tgt="${e.tgtKey}" x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="${color}" stroke-width="${w}" opacity="${op}"/>`;
                }
            }

            for (const key in nodePositions) {
                const pos = nodePositions[key];
                const [layer, seqIdx, cIdx] = key.split(':');
                const info = parseLayer(layer);
                const outAttr = nodeOutAttr[key] || 0;
                const intensity = Math.min(1, outAttr / maxNodeOutAttr);
                const baseColor = COLORS[info.subtype] || '#999';
                const opacity = 0.2 + intensity * 0.8;
                html += `<rect class="node" data-layer="${layer}" data-seq="${seqIdx}" data-cidx="${cIdx}" x="${pos.x - COMPONENT_SIZE/2}" y="${pos.y - COMPONENT_SIZE/2}" width="${COMPONENT_SIZE}" height="${COMPONENT_SIZE}" fill="${baseColor}" rx="1" opacity="${opacity}" style="cursor:pointer"><title>${layer} seq=${seqIdx} c=${cIdx}\nOut attr: ${outAttr.toFixed(4)}</title></rect>`;
            }

            svg.innerHTML = html;

            let tokenHtml = `<svg width="${width}" height="50" style="display:block;">`;
            for (let i = 0; i < data.tokens.length; i++) {
                const colCenter = seqXStarts[i] + seqWidths[i] / 2;
                tokenHtml += `<text x="${colCenter}" y="20" text-anchor="middle" font-size="12" font-family="monospace" font-weight="500">${escapeHtml(data.tokens[i])}</text>`;
                tokenHtml += `<text x="${colCenter}" y="38" text-anchor="middle" font-size="10" fill="#999">[${i}]</text>`;
            }
            tokenHtml += '</svg>';
            document.getElementById('token-labels').innerHTML = tokenHtml;

            let layerHtml = `<svg width="${LABEL_WIDTH}" height="${height}" style="display:block;">`;
            for (const layer in layerYPositions) {
                const info = parseLayer(layer);
                const y = layerYPositions[layer] + COMPONENT_SIZE / 2;
                layerHtml += `<text x="${LABEL_WIDTH - 10}" y="${y}" text-anchor="end" dominant-baseline="middle" font-size="11" font-weight="500" fill="${COLORS[info.subtype]}">${info.subtype}</text>`;
            }
            layerHtml += '</svg>';
            document.getElementById('layer-labels').innerHTML = layerHtml;

            const nodes = svg.querySelectorAll('.node');
            nodes.forEach((node, i) => {
                node.addEventListener('mouseenter', (e) => {
                    const layer = node.getAttribute('data-layer');
                    const seqIdx = node.getAttribute('data-seq');
                    const cIdx = parseInt(node.getAttribute('data-cidx'));
                    const nodeKey = `${layer}:${seqIdx}:${cIdx}`;
                    hoveredNodeKey = nodeKey;
                    highlightForNode(nodeKey, layer, cIdx);
                    showNodeDetails(layer, cIdx, e.clientX, e.clientY);
                });
                node.addEventListener('mouseleave', () => {
                    hoveredNodeKey = null;
                    if (pinnedNodes.length > 0) {
                        updatePinnedDisplay();
                    }
                    hideNodeDetails();
                });
                node.addEventListener('click', (e) => {
                    document.getElementById('node-details').style.display = 'none';
                    hoveredNodeKey = null;

                    const layer = node.getAttribute('data-layer');
                    const seqIdx = node.getAttribute('data-seq');
                    const cIdx = parseInt(node.getAttribute('data-cidx'));
                    const nodeKey = `${layer}:${seqIdx}:${cIdx}`;
                    pinNode(layer, cIdx, nodeKey);
                });
            });

            const detailsEl = document.getElementById('node-details');
            detailsEl.addEventListener('mouseenter', () => {
                isHoveringTooltip = true;
            });
            detailsEl.addEventListener('mouseleave', () => {
                isHoveringTooltip = false;
                hideNodeDetails();
            });
        }

        // Initialize
        document.getElementById('topk-edges').addEventListener('input', render);
        document.getElementById('max-mean-ci').addEventListener('input', render);

        // Load data from server
        loadData();
    </script>
</body>
</html>
