<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Attributions Graph (Canvas)</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #fafafa;
            display: flex;
            height: 100vh;
        }
        /* Sidebar styles */
        .sidebar {
            width: 280px;
            background: #fff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
            background: #f5f5f5;
        }
        .sidebar-header h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; }
        .search-btn {
            width: 100%;
            padding: 0.5rem;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .search-btn:hover { background: #1976d2; }
        .search-btn:disabled { background: #ccc; cursor: not-allowed; }
        .search-info {
            padding: 0.5rem 1rem;
            background: #e3f2fd;
            font-size: 0.8rem;
            color: #1565c0;
        }
        .search-results {
            flex: 1;
            overflow-y: auto;
        }
        .search-result {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.15s;
        }
        .search-result:hover { background: #f5f5f5; }
        .search-result.active { background: #e3f2fd; border-left: 3px solid #2196f3; }
        .search-result-id { font-size: 0.75rem; color: #666; margin-bottom: 0.25rem; }
        .search-result-preview {
            font-family: monospace;
            font-size: 0.8rem;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* Main content */
        .main-content {
            flex: 1;
            padding: 1rem;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }
        h1 { margin-top: 0; font-size: 1.5rem; }
        .controls {
            display: flex;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-wrap: wrap;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .controls input[type="number"] {
            width: 80px;
            padding: 0.25rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .controls select {
            padding: 0.25rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }
        .edge-count { color: #666; font-size: 0.9rem; }
        .db-info { color: #666; font-size: 0.85rem; margin-left: auto; }
        .graph-wrapper {
            display: flex;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .layer-labels-container {
            background: white;
            border-right: 1px solid #eee;
            flex-shrink: 0;
        }
        .graph-container {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 400px;
            max-height: 70vh;
        }
        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        .graph-canvas {
            display: block;
            cursor: grab;
        }
        .graph-canvas:active {
            cursor: grabbing;
        }
        .token-labels-container {
            background: white;
            border-top: 1px solid #eee;
            flex-shrink: 0;
        }
        svg { display: block; }
        .edge-pos, .edge-neg { display: inline-block; width: 30px; height: 3px; margin-right: 0.25rem; vertical-align: middle; }
        .edge-pos { background: #2196f3; }
        .edge-neg { background: #f44336; }
        .legend { color: #666; font-size: 0.85rem; display: flex; align-items: center; gap: 0.75rem; }
        .edge-tooltip {
            position: fixed;
            padding: 0.5rem 0.75rem;
            background: #fff;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1001;
            pointer-events: none;
            font-size: 0.85rem;
        }
        .edge-tooltip-row { margin: 0.2rem 0; }
        .edge-tooltip-label { color: #666; margin-right: 0.5rem; }
        .edge-tooltip-code { background: #f5f5f5; padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.8rem; font-family: monospace; }
        .node-local-section {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }
        .node-local-section h4 { margin: 0 0 0.25rem 0; font-size: 0.8rem; color: #1565c0; }
        .component-section h4 { margin: 0.75rem 0 0.25rem 0; font-size: 0.85rem; color: #333; }
        .loading { padding: 2rem; text-align: center; color: #666; }
        .error-banner {
            padding: 0.75rem 1rem;
            background: #ffebee;
            border: 1px solid #f44336;
            border-radius: 4px;
            color: #c62828;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .error-banner button {
            margin-left: auto;
            padding: 0.25rem 0.5rem;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .error-banner button:hover { background: #d32f2f; }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #e0e0e0;
            border-top-color: #2196f3;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loading-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #666;
        }
        .search-error {
            padding: 0.5rem 1rem;
            background: #ffebee;
            color: #c62828;
            font-size: 0.8rem;
        }
        .node-details {
            position: fixed;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            max-width: 1000px;
            max-height: 800px;
            overflow-y: auto;
            z-index: 1000;
            pointer-events: auto;
        }
        .pinned-container {
            margin-top: 1rem;
            padding: 1rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .pinned-container h3 {
            margin: 0 0 0.75rem 0;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .pinned-items {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }
        .pinned-item {
            flex-shrink: 0;
            min-width: 350px;
            max-width: 500px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
            background: #fafafa;
        }
        .pinned-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .unpin-btn {
            cursor: pointer;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }
        .example-row {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin: 0.5rem 0;
            font-family: monospace;
            font-size: 0.85rem;
        }
        .example-token {
            padding: 2px 4px;
            border-radius: 2px;
        }
        .example-token.active {
            font-weight: bold;
            border: 1px solid #333;
        }
        .pr-table { font-size: 0.85rem; margin-top: 0.5rem; }
        .pr-table th, .pr-table td { padding: 0.25rem 0.5rem; text-align: left; }
        .stats { margin: 0.25rem 0; font-size: 0.85rem; }
        h4 { margin: 0.75rem 0 0.25rem 0; font-size: 0.85rem; }
        .tables-row { display: flex; gap: 2rem; flex-wrap: wrap; }
        .canvas-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
            z-index: 10;
        }
        .canvas-controls button {
            padding: 4px 8px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .canvas-controls button:hover {
            background: #f0f0f0;
        }
    </style>
</head>
<body x-data="app()">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h3>Search Prompts</h3>
            <button
                class="search-btn"
                :disabled="pinnedNodes.length === 0 || searchLoading"
                @click="searchPrompts"
            >
                <template x-if="searchLoading">
                    <span class="loading-text"><span class="loading-spinner"></span> Searching...</span>
                </template>
                <template x-if="!searchLoading">
                    <span x-text="pinnedNodes.length === 0 ? 'Pin components to search' : `Find prompts with ${pinnedNodes.length} pinned component${pinnedNodes.length > 1 ? 's' : ''}`"></span>
                </template>
            </button>
        </div>
        <div class="search-error" x-show="searchError" x-text="searchError"></div>
        <div class="search-info" x-show="searchResults.length > 0 && !searchError">
            Found <span x-text="searchResults.length"></span> prompt<span x-show="searchResults.length !== 1">s</span>
        </div>
        <div class="search-results">
            <template x-for="p in searchResults" :key="p.id">
                <div
                    class="search-result"
                    :class="{ active: p.id === currentPromptId }"
                    @click="loadPrompt(p.id)"
                >
                    <div class="search-result-id">Prompt #<span x-text="p.id"></span></div>
                    <div class="search-result-preview" x-text="p.preview"></div>
                </div>
            </template>
        </div>
    </div>

    <!-- Main content -->
    <div class="main-content">
        <h1>Local Attributions Graph <span style="font-size: 0.6em; color: #888;">(Canvas)</span></h1>

        <!-- Loading state -->
        <div class="loading" x-show="loading" x-text="loadingMessage"></div>

        <!-- Main app -->
        <div x-show="!loading">
            <!-- Error banner for prompt loading -->
            <div class="error-banner" x-show="promptError">
                <span x-text="promptError"></span>
                <button @click="loadPrompt(currentPromptId)">Retry</button>
            </div>

            <div class="controls">
                <label>
                    Prompt:
                    <select x-model="currentPromptId" @change="loadPrompt(parseInt($event.target.value))">
                        <template x-for="p in allPrompts" :key="p.id">
                            <option :value="p.id" x-text="`${p.id}: ${p.preview}`"></option>
                        </template>
                    </select>
                </label>
                <label>
                    Max mean CI:
                    <input type="number" x-model.number="maxMeanCI" min="0" max="1" step="0.01" @change="reloadWithFilters()">
                </label>
                <label>
                    Top K edges:
                    <input type="number" x-model.number="topK" min="10" max="10000" step="100" @change="render()">
                </label>
                <label>
                    Node layout:
                    <select x-model="nodeLayout" @change="render()">
                        <option value="jittered">Jittered</option>
                        <option value="shuffled">Shuffled</option>
                        <option value="importance">By importance</option>
                    </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.25rem;">
                    <input type="checkbox" x-model="normalizeEdges" @change="reloadWithFilters()">
                    Normalize edges
                </label>
                <label style="display: flex; align-items: center; gap: 0.25rem;">
                    <input type="checkbox" x-model="useOptimized">
                    Optimize CI
                </label>
                <template x-if="useOptimized">
                    <div style="display: flex; gap: 1rem; align-items: center; padding: 0.5rem; background: #e8f5e9; border-radius: 4px;">
                        <label style="display: flex; align-items: center; gap: 0.25rem;">
                            imp_min:
                            <input type="number" x-model.number="impMinCoeff" min="0.001" max="10" step="0.01" style="width: 70px;">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.25rem;">
                            ce:
                            <input type="number" x-model.number="ceLossCoeff" min="0.001" max="10" step="0.1" style="width: 70px;">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.25rem;">
                            steps:
                            <input type="number" x-model.number="optimSteps" min="10" max="5000" step="100" style="width: 70px;">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.25rem;">
                            pnorm:
                            <input type="number" x-model.number="optimPnorm" min="0.1" max="1" step="0.1" style="width: 60px;">
                        </label>
                        <button
                            @click="reloadWithFilters()"
                            :disabled="promptLoading"
                            style="padding: 0.4rem 0.8rem; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;"
                        >
                            Run
                        </button>
                    </div>
                </template>
                <template x-if="optimizationResult">
                    <div style="display: flex; gap: 1rem; align-items: center; padding: 0.5rem 0.75rem; background: #fff3e0; border-radius: 4px; font-size: 0.85rem;">
                        <span>
                            <strong>Target:</strong> "<span x-text="optimizationResult.label_str"></span>"
                            @ <span x-text="(optimizationResult.label_prob * 100).toFixed(1)"></span>%
                        </span>
                        <span>
                            <strong>L0:</strong> <span x-text="optimizationResult.l0_total.toFixed(0)"></span> active
                        </span>
                    </div>
                </template>
                <span class="edge-count">Showing <span x-text="visibleEdgeCount"></span> edges</span>
                <span class="legend">
                    <span class="edge-pos"></span><span x-text="normalizeEdges ? '+1' : '+' + maxAbsAttr.toFixed(2)"></span>
                    <span class="edge-neg"></span><span x-text="normalizeEdges ? '-1' : '-' + maxAbsAttr.toFixed(2)"></span>
                    <span style="opacity: 0.3;">faint</span> -> <span style="opacity: 1;">solid</span> = |strength|
                </span>
                <span class="db-info">DB: <span x-text="promptCount"></span> prompts</span>
            </div>

            <div class="graph-wrapper" style="position: relative;">
                <!-- Loading overlay -->
                <div class="loading-overlay" x-show="promptLoading">
                    <span class="loading-text"><span class="loading-spinner"></span> Loading prompt...</span>
                </div>
                <div class="layer-labels-container" x-ref="layerLabels"></div>
                <div class="graph-container">
                    <div class="canvas-wrapper" x-ref="canvasWrapper">
                        <canvas class="graph-canvas" x-ref="graphCanvas"></canvas>
                        <div class="canvas-controls">
                            <button @click="resetView()" title="Reset zoom/pan">Reset</button>
                        </div>
                    </div>
                    <div class="token-labels-container" x-ref="tokenLabels"></div>
                </div>
            </div>

            <!-- Pinned components -->
            <div class="pinned-container" x-show="pinnedNodes.length > 0">
                <h3>
                    <span>Pinned Components</span>
                    <button @click="pinnedNodes = []" style="font-size: 0.8rem; padding: 0.25rem 0.5rem; cursor: pointer;">Clear all</button>
                </h3>
                <div class="pinned-items">
                    <template x-for="pinned in pinnedNodes" :key="`${pinned.layer}:${pinned.cIdx}`">
                        <div class="pinned-item">
                            <div class="pinned-item-header">
                                <strong x-text="`${pinned.layer}:${pinned.cIdx}`"></strong>
                                <button class="unpin-btn" @click="unpinNode(pinned.layer, pinned.cIdx)">X unpin</button>
                            </div>
                            <template x-if="pinned.layer === 'output' || activationContextsSummary">
                                <div x-html="buildComponentHtmlNoSeq(pinned.layer, pinned.cIdx)"></div>
                            </template>
                            <template x-if="pinned.layer !== 'output' && !activationContextsSummary && activationContextsLoading">
                                <div class="loading-text"><span class="loading-spinner"></span> Loading details...</div>
                            </template>
                            <template x-if="pinned.layer !== 'output' && !activationContextsSummary && !activationContextsLoading && activationContextsError">
                                <div style="color: #c62828; font-size: 0.85rem;" x-text="activationContextsError"></div>
                            </template>
                            <template x-if="pinned.layer !== 'output' && !activationContextsSummary && !activationContextsLoading && !activationContextsError">
                                <div style="color: #666; font-size: 0.85rem;">No component details available</div>
                            </template>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Hover tooltip -->
            <div
                class="node-details"
                x-show="hoveredNode && !isNodePinned(hoveredNode.layer, hoveredNode.cIdx)"
                :style="`left: ${tooltipPos.x}px; top: ${tooltipPos.y}px`"
                @mouseenter="isHoveringTooltip = true"
                @mouseleave="isHoveringTooltip = false; maybeHideTooltip()"
            >
                <!-- Local section first (for non-output nodes) -->
                <template x-if="hoveredNode && hoveredNode.layer !== 'output'">
                    <div x-html="buildLocalSectionHtml(hoveredNode.layer, hoveredNode.seqIdx, hoveredNode.cIdx)"></div>
                </template>

                <h3>Component Details</h3>

                <template x-if="hoveredNode && hoveredNode.layer === 'output'">
                    <div x-html="buildComponentHtml(hoveredNode.layer, hoveredNode.seqIdx, hoveredNode.cIdx)"></div>
                </template>
                <template x-if="hoveredNode && hoveredNode.layer !== 'output' && !activationContextsSummary && activationContextsLoading">
                    <p class="loading-text"><span class="loading-spinner"></span> Loading component details...</p>
                </template>
                <template x-if="hoveredNode && hoveredNode.layer !== 'output' && !activationContextsSummary && !activationContextsLoading && activationContextsError">
                    <p style="color: #c62828;" x-text="activationContextsError"></p>
                </template>
                <template x-if="hoveredNode && hoveredNode.layer !== 'output' && !activationContextsSummary && !activationContextsLoading && !activationContextsError">
                    <p style="color: #666;">No component details available</p>
                </template>
                <template x-if="hoveredNode && hoveredNode.layer !== 'output' && activationContextsSummary">
                    <div x-html="buildComponentHtml(hoveredNode.layer, hoveredNode.seqIdx, hoveredNode.cIdx)"></div>
                </template>
            </div>

            <!-- Edge hover tooltip -->
            <div
                class="edge-tooltip"
                x-show="hoveredEdge"
                :style="`left: ${edgeTooltipPos.x}px; top: ${edgeTooltipPos.y}px`"
            >
                <template x-if="hoveredEdge">
                    <div>
                        <div class="edge-tooltip-row">
                            <span class="edge-tooltip-label">From:</span>
                            <span class="edge-tooltip-code" x-text="hoveredEdge.src"></span>
                        </div>
                        <div class="edge-tooltip-row">
                            <span class="edge-tooltip-label">To:</span>
                            <span class="edge-tooltip-code" x-text="hoveredEdge.tgt"></span>
                        </div>
                        <div class="edge-tooltip-row">
                            <span class="edge-tooltip-label">Strength:</span>
                            <span :style="`color: ${hoveredEdge.val > 0 ? '#2196f3' : '#f44336'}; font-weight: bold;`" x-text="hoveredEdge.val.toFixed(4)"></span>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </div>

    <script src="graph_canvas_renderer.js"></script>
    <script>
        const COMPONENT_SIZE = 8;
        const COMPONENT_GAP = 2;
        const LAYER_GAP = 30;
        const MARGIN = { top: 60, right: 40, bottom: 20, left: 20 };
        const LABEL_WIDTH = 100;
        const ROW_ORDER = ['wte', 'qkv', 'o_proj', 'c_fc', 'down_proj', 'output'];
        const QKV_SUBTYPES = ['q_proj', 'k_proj', 'v_proj'];
        const NODE_COLOR = "#333";

        const MAX_EXAMPLES_DISPLAY = 50;
        const MAX_TOP_TOKENS_DISPLAY = 30;
        const MAX_PREDICTED_TOKENS_DISPLAY = 30;
        const DEFAULT_TOP_K_EDGES = 800;

        const timers = {};
        function timeStart(label) { timers[label] = performance.now(); }
        function timeEnd(label) {
            if (timers[label]) {
                console.log(`[timing] ${label}: ${(performance.now() - timers[label]).toFixed(1)}ms`);
                delete timers[label];
            }
        }

        // Cached div for HTML escaping
        const escapeDiv = document.createElement('div');

        function app() {
            return {
                NODE_COLOR,
                apiBase: window.location.origin || 'http://localhost:8765',

                // Loading state
                loading: true,
                loadingMessage: 'Loading data...',
                promptLoading: false,
                promptError: null,
                searchLoading: false,
                searchError: null,
                activationContextsError: null,

                // Data
                promptCount: 0,
                allPrompts: [],
                currentPromptId: null,
                promptData: null,
                activationContextsSummary: null,
                componentDetailsCache: {},
                componentDetailsLoading: {},
                activationContextsLoading: false,

                // Computed from prompt data
                allEdges: [],
                componentImportance: {},
                componentImportanceLocal: {},
                maxAbsAttr: 1,
                maxImportanceLocal: 1,

                // UI state
                maxMeanCI: 1.0,
                topK: DEFAULT_TOP_K_EDGES,
                normalizeEdges: true,
                nodeLayout: 'importance',
                visibleEdgeCount: 0,

                // Optimization controls
                useOptimized: false,
                impMinCoeff: 0.1,
                ceLossCoeff: 1.0,
                optimSteps: 500,
                optimLr: 0.01,
                optimPnorm: 0.3,
                optimizationResult: null,
                pinnedNodes: [],
                hoveredNode: null,
                hoveredEdge: null,
                isHoveringTooltip: false,
                tooltipPos: { x: 0, y: 0 },
                edgeTooltipPos: { x: 0, y: 0 },
                searchResults: [],

                // Layout cache
                layerYPositions: {},
                nodePositions: {},
                graphWidth: 0,
                graphHeight: 0,

                // Canvas renderer
                renderer: null,
                lastMouseEvent: null,

                async init() {
                    timeStart('init.total');
                    try {
                        const metaResponse = await fetch(`${this.apiBase}/api/meta`);
                        if (!metaResponse.ok) throw new Error(`Server error: ${metaResponse.status}`);
                        const meta = await metaResponse.json();
                        this.promptCount = meta.prompt_count;

                        if (meta.prompt_count > 0) {
                            const promptsResponse = await fetch(`${this.apiBase}/api/prompts`);
                            if (!promptsResponse.ok) throw new Error(`Server error: ${promptsResponse.status}`);
                            this.allPrompts = await promptsResponse.json();

                            await this.loadPrompt(1);
                            this.loadActivationContexts();
                        } else {
                            this.loadingMessage = 'No prompts in database';
                        }
                    } catch (e) {
                        this.loadingMessage = `Error connecting to server: ${e.message}. Make sure the server is running.`;
                        console.error(e);
                    }
                    timeEnd('init.total');
                },

                initRenderer() {
                    if (this.renderer) return;

                    const canvas = this.$refs.graphCanvas;
                    if (!canvas) return;

                    this.renderer = new GraphCanvasRenderer(canvas);

                    // Wire up callbacks
                    this.renderer.onNodeHover = (node) => {
                        if (node) {
                            this.hoveredNode = {
                                layer: node.layer,
                                seqIdx: node.seqIdx,
                                cIdx: node.cIdx
                            };
                            if (this.lastMouseEvent) {
                                this.tooltipPos = this.calcTooltipPos(this.lastMouseEvent.clientX, this.lastMouseEvent.clientY);
                            }
                            if (node.layer !== 'output' && !this.activationContextsSummary) {
                                this.loadActivationContexts();
                            }
                        } else {
                            this.maybeHideTooltip();
                        }
                        this.hoveredEdge = null;
                    };

                    this.renderer.onNodeClick = (node) => {
                        this.togglePin(node.layer, node.cIdx);
                    };

                    this.renderer.onEdgeHover = (edge) => {
                        if (edge) {
                            this.hoveredEdge = { src: edge.srcKey, tgt: edge.tgtKey, val: edge.val };
                            if (this.lastMouseEvent) {
                                this.edgeTooltipPos = { x: this.lastMouseEvent.clientX + 10, y: this.lastMouseEvent.clientY + 10 };
                            }
                        } else {
                            this.hoveredEdge = null;
                        }
                        this.hoveredNode = null;
                    };

                    // Track mouse position for tooltip placement
                    canvas.addEventListener('mousemove', (e) => {
                        this.lastMouseEvent = e;
                    });
                },

                resetView() {
                    if (this.renderer) {
                        this.renderer.resetView();
                    }
                },

                async loadPrompt(promptId) {
                    if (this.promptLoading) return;

                    timeStart('loadPrompt.total');
                    this.currentPromptId = promptId;
                    this.promptLoading = true;
                    this.promptError = null;

                    try {
                        const params = new URLSearchParams({
                            max_mean_ci: this.maxMeanCI,
                            normalize: this.normalizeEdges,
                        });

                        let endpoint = `/api/prompt/${promptId}`;
                        if (this.useOptimized) {
                            endpoint = `/api/prompt/${promptId}/optimized`;
                            params.set('imp_min_coeff', this.impMinCoeff);
                            params.set('ce_loss_coeff', this.ceLossCoeff);
                            params.set('steps', this.optimSteps);
                            params.set('lr', this.optimLr);
                            params.set('pnorm', this.optimPnorm);
                        }

                        const response = await fetch(`${this.apiBase}${endpoint}?${params}`);
                        if (!response.ok) throw new Error(`Server error: ${response.status}`);
                        const promptData = await response.json();
                        if (promptData.error) throw new Error(promptData.error);

                        this.promptData = promptData;
                        this.optimizationResult = promptData.optimization || null;

                        this.allEdges = promptData.edges.map(edge => ({
                            srcKey: edge.src,
                            tgtKey: edge.tgt,
                            val: edge.val,
                        }));

                        this.maxAbsAttr = 1;
                        for (const edge of this.allEdges) {
                            const absVal = Math.abs(edge.val);
                            if (absVal > this.maxAbsAttr) this.maxAbsAttr = absVal;
                        }

                        this.componentImportance = {};
                        this.componentImportanceLocal = {};
                        for (const edge of this.allEdges) {
                            const valSq = edge.val * edge.val;
                            const [srcLayer, , srcCIdx] = edge.srcKey.split(':');
                            const [tgtLayer, , tgtCIdx] = edge.tgtKey.split(':');
                            const srcGlobalKey = `${srcLayer}:${srcCIdx}`;
                            const tgtGlobalKey = `${tgtLayer}:${tgtCIdx}`;

                            this.componentImportance[srcGlobalKey] = (this.componentImportance[srcGlobalKey] || 0) + valSq;
                            this.componentImportance[tgtGlobalKey] = (this.componentImportance[tgtGlobalKey] || 0) + valSq;
                            this.componentImportanceLocal[edge.srcKey] = (this.componentImportanceLocal[edge.srcKey] || 0) + valSq;
                            this.componentImportanceLocal[edge.tgtKey] = (this.componentImportanceLocal[edge.tgtKey] || 0) + valSq;
                        }

                        this.maxImportanceLocal = 1;
                        for (const imp of Object.values(this.componentImportanceLocal)) {
                            if (imp > this.maxImportanceLocal) this.maxImportanceLocal = imp;
                        }

                        this.loading = false;
                        this.$nextTick(() => {
                            this.initRenderer();
                            this.render();
                            timeEnd('loadPrompt.total');
                        });
                    } catch (e) {
                        console.error('Error loading prompt:', e);
                        this.promptError = `Failed to load prompt: ${e.message}`;
                        this.loading = false;
                        timeEnd('loadPrompt.total');
                    } finally {
                        this.promptLoading = false;
                    }
                },

                async reloadWithFilters() {
                    if (!this.currentPromptId) return;
                    await this.loadPrompt(this.currentPromptId);
                },

                async loadActivationContexts() {
                    if (this.activationContextsSummary || this.activationContextsLoading) return;
                    this.activationContextsLoading = true;
                    this.activationContextsError = null;

                    try {
                        const response = await fetch(`${this.apiBase}/api/activation_contexts/summary`);
                        if (!response.ok) throw new Error(`Server error: ${response.status}`);
                        const data = await response.json();
                        if (data.error) throw new Error(data.error);
                        this.activationContextsSummary = data;
                    } catch (e) {
                        console.error('Error loading activation contexts:', e);
                        this.activationContextsError = `Failed to load component details: ${e.message}`;
                    } finally {
                        this.activationContextsLoading = false;
                    }
                },

                async loadComponentDetail(layer, cIdx) {
                    const cacheKey = `${layer}:${cIdx}`;
                    if (this.componentDetailsCache[cacheKey] || this.componentDetailsLoading[cacheKey]) return;

                    this.componentDetailsLoading[cacheKey] = true;
                    try {
                        const response = await fetch(`${this.apiBase}/api/activation_contexts/${encodeURIComponent(layer)}/${cIdx}`);
                        if (!response.ok) throw new Error(`Server error: ${response.status}`);
                        const data = await response.json();
                        if (!data.error) this.componentDetailsCache[cacheKey] = data;
                    } catch (e) {
                        console.error(`Error loading component detail for ${cacheKey}:`, e);
                    } finally {
                        this.componentDetailsLoading[cacheKey] = false;
                    }
                },

                getComponentDetail(layer, cIdx) {
                    const cacheKey = `${layer}:${cIdx}`;
                    if (this.componentDetailsCache[cacheKey]) return this.componentDetailsCache[cacheKey];
                    this.loadComponentDetail(layer, cIdx);
                    return null;
                },

                parseLayer(name) {
                    if (name === 'wte') return { name, block: -1, type: 'embed', subtype: 'wte' };
                    if (name === 'output') return { name, block: Infinity, type: 'output', subtype: 'output' };
                    const m = name.match(/h\.(\d+)\.(attn|mlp)\.(\w+)/);
                    if (!m) throw new Error(`parseLayer: unrecognized layer name: ${name}`);
                    return { name, block: +m[1], type: m[2], subtype: m[3] };
                },

                getRowKey(layer) {
                    const info = this.parseLayer(layer);
                    if (QKV_SUBTYPES.includes(info.subtype)) return `h.${info.block}.qkv`;
                    return layer;
                },

                getFilteredEdgesAndNodes() {
                    const sortedEdges = [...this.allEdges].sort((a, b) => Math.abs(b.val) - Math.abs(a.val));
                    const filteredEdges = sortedEdges.slice(0, this.topK);

                    const activeNodes = new Set();
                    for (const edge of filteredEdges) {
                        activeNodes.add(edge.srcKey);
                        activeNodes.add(edge.tgtKey);
                    }

                    const outputNodesWithEdges = new Set();
                    for (const nodeKey of activeNodes) {
                        if (nodeKey.startsWith('output:')) outputNodesWithEdges.add(nodeKey);
                    }

                    if (outputNodesWithEdges.size > 0) {
                        let minProb = Infinity;
                        for (const nodeKey of outputNodesWithEdges) {
                            const [, seqIdx, cIdx] = nodeKey.split(':');
                            const entry = this.promptData.outputProbs[`${seqIdx}:${cIdx}`];
                            if (entry && entry.prob < minProb) minProb = entry.prob;
                        }

                        for (const [probKey, entry] of Object.entries(this.promptData.outputProbs)) {
                            if (entry.prob >= minProb) {
                                const [seqIdx, cIdx] = probKey.split(':');
                                activeNodes.add(`output:${seqIdx}:${cIdx}`);
                            }
                        }
                    }

                    return { edges: filteredEdges, activeNodes };
                },

                buildLayout(activeNodes) {
                    const nodesPerLayerSeq = {};
                    const allLayers = new Set();
                    const allRows = new Set();

                    for (const nodeKey of activeNodes) {
                        const [layer, seqIdx, cIdx] = nodeKey.split(':');
                        allLayers.add(layer);
                        allRows.add(this.getRowKey(layer));
                        const key = `${layer}:${seqIdx}`;
                        if (!nodesPerLayerSeq[key]) nodesPerLayerSeq[key] = [];
                        nodesPerLayerSeq[key].push(+cIdx);
                    }

                    const parseRow = (r) => {
                        if (r === 'wte') return { block: -1, subtype: 'wte' };
                        if (r === 'output') return { block: Infinity, subtype: 'output' };
                        const mQkv = r.match(/h\.(\d+)\.qkv/);
                        if (mQkv) return { block: +mQkv[1], subtype: 'qkv' };
                        const m = r.match(/h\.(\d+)\.(attn|mlp)\.(\w+)/);
                        if (!m) throw new Error(`parseRow: unrecognized row key: ${r}`);
                        return { block: +m[1], subtype: m[3] };
                    };

                    const rows = Array.from(allRows).sort((a, b) => {
                        const infoA = parseRow(a);
                        const infoB = parseRow(b);
                        if (infoA.block !== infoB.block) return infoA.block - infoB.block;
                        return ROW_ORDER.indexOf(infoA.subtype) - ROW_ORDER.indexOf(infoB.subtype);
                    });

                    const rowYPositions = {};
                    let currentY = MARGIN.top;
                    for (const row of rows.slice().reverse()) {
                        rowYPositions[row] = currentY;
                        currentY += COMPONENT_SIZE + LAYER_GAP;
                    }

                    this.layerYPositions = {};
                    for (const layer of allLayers) {
                        this.layerYPositions[layer] = rowYPositions[this.getRowKey(layer)];
                    }

                    const tokens = this.promptData.tokens;

                    const maxComponentsPerSeq = tokens.map((_, seqIdx) => {
                        let maxAtSeq = 0;
                        for (const row of rows) {
                            if (row.endsWith('.qkv')) {
                                const block = row.match(/h\.(\d+)/)[1];
                                let totalQkv = 0;
                                for (const subtype of QKV_SUBTYPES) {
                                    const layer = `h.${block}.attn.${subtype}`;
                                    totalQkv += (nodesPerLayerSeq[`${layer}:${seqIdx}`] ?? []).length;
                                }
                                totalQkv += 2;
                                maxAtSeq = Math.max(maxAtSeq, totalQkv);
                            } else {
                                for (const layer of allLayers) {
                                    if (this.getRowKey(layer) === row) {
                                        maxAtSeq = Math.max(maxAtSeq, (nodesPerLayerSeq[`${layer}:${seqIdx}`] ?? []).length);
                                    }
                                }
                            }
                        }
                        return maxAtSeq;
                    });

                    const MIN_COL_WIDTH = 30, COL_PADDING = 16;
                    const seqWidths = maxComponentsPerSeq.map(n =>
                        Math.max(MIN_COL_WIDTH, n * (COMPONENT_SIZE + COMPONENT_GAP) + COL_PADDING * 2)
                    );
                    const seqXStarts = [MARGIN.left];
                    for (let i = 0; i < seqWidths.length - 1; i++) {
                        seqXStarts.push(seqXStarts[i] + seqWidths[i]);
                    }

                    this.nodePositions = {};
                    const QkV_GROUP_GAP = COMPONENT_SIZE + COMPONENT_GAP;

                    for (const layer of allLayers) {
                        const info = this.parseLayer(layer);
                        const isQkv = info && QKV_SUBTYPES.includes(info.subtype);
                        const isOutput = layer === 'output';

                        for (let seqIdx = 0; seqIdx < tokens.length; seqIdx++) {
                            const nodes = nodesPerLayerSeq[`${layer}:${seqIdx}`];
                            if (!nodes) continue;

                            let baseX = seqXStarts[seqIdx] + COL_PADDING;
                            const baseY = this.layerYPositions[layer];

                            if (isQkv) {
                                const subtypeIdx = QKV_SUBTYPES.indexOf(info.subtype);
                                for (let i = 0; i < subtypeIdx; i++) {
                                    const prevLayer = `h.${info.block}.attn.${QKV_SUBTYPES[i]}`;
                                    baseX += (nodesPerLayerSeq[`${prevLayer}:${seqIdx}`]?.length ?? 0) * (COMPONENT_SIZE + COMPONENT_GAP);
                                    baseX += QkV_GROUP_GAP;
                                }
                            }

                            const cellWidth = seqWidths[seqIdx] - COL_PADDING * 2;
                            const offsets = this.getComponentOffsetsForLayout(nodes, layer, seqIdx, isOutput, cellWidth);

                            for (const cIdx of nodes) {
                                this.nodePositions[`${layer}:${seqIdx}:${cIdx}`] = {
                                    x: baseX + offsets[cIdx] + COMPONENT_SIZE / 2,
                                    y: baseY + COMPONENT_SIZE / 2
                                };
                            }
                        }
                    }

                    return { rows, seqWidths, seqXStarts };
                },

                getComponentOffsetsForLayout(components, layer, seqIdx, isOutput, cellWidth) {
                    const n = components.length;
                    const offsets = {};

                    if (this.nodeLayout === 'importance') {
                        const sorted = [...components].sort((a, b) => {
                            if (isOutput) {
                                const entryA = this.promptData.outputProbs[`${seqIdx}:${a}`];
                                const entryB = this.promptData.outputProbs[`${seqIdx}:${b}`];
                                return (entryB?.prob || 0) - (entryA?.prob || 0);
                            }
                            return (this.componentImportanceLocal[`${layer}:${seqIdx}:${b}`] || 0) -
                                   (this.componentImportanceLocal[`${layer}:${seqIdx}:${a}`] || 0);
                        });
                        for (let i = 0; i < n; i++) {
                            offsets[sorted[i]] = i * (COMPONENT_SIZE + COMPONENT_GAP);
                        }
                        return offsets;
                    }

                    if (this.nodeLayout === 'shuffled') {
                        const seed = this.hashString(`${layer}:${seqIdx}`);
                        const shuffled = this.seededShuffle([...components], seed);
                        for (let i = 0; i < n; i++) {
                            offsets[shuffled[i]] = i * (COMPONENT_SIZE + COMPONENT_GAP);
                        }
                        return offsets;
                    }

                    if (this.nodeLayout === 'jittered') {
                        const seed = this.hashString(`${layer}:${seqIdx}`);
                        const shuffled = this.seededShuffle([...components], seed);
                        let jitterSeed = seed;
                        const jitterRandom = () => {
                            jitterSeed |= 0; jitterSeed = jitterSeed + 0x6D2B79F5 | 0;
                            let t = Math.imul(jitterSeed ^ jitterSeed >>> 15, 1 | jitterSeed);
                            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                            return ((t ^ t >>> 14) >>> 0) / 4294967296;
                        };

                        const totalSpace = cellWidth - n * COMPONENT_SIZE;
                        const gap = totalSpace / (n + 1);
                        const maxJitter = gap / 2;

                        for (let i = 0; i < n; i++) {
                            const baseOffset = gap + i * (COMPONENT_SIZE + gap);
                            const jitter = (jitterRandom() - 0.5) * 2 * maxJitter;
                            offsets[shuffled[i]] = Math.max(0, Math.min(cellWidth - COMPONENT_SIZE, baseOffset + jitter));
                        }
                        return offsets;
                    }

                    throw new Error(`Unknown node layout: ${this.nodeLayout}`);
                },

                hashString(str) {
                    let hash = 0;
                    for (let i = 0; i < str.length; i++) {
                        hash = ((hash << 5) - hash) + str.charCodeAt(i);
                        hash = hash & hash;
                    }
                    return Math.abs(hash);
                },

                seededShuffle(arr, seed) {
                    const random = () => {
                        seed |= 0; seed = seed + 0x6D2B79F5 | 0;
                        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                        return ((t ^ t >>> 14) >>> 0) / 4294967296;
                    };
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    return arr;
                },

                linearInterpolate(min, max, x) {
                    return min + (max - min) * x;
                },

                render() {
                    if (!this.promptData || !this.renderer) return;

                    timeStart('render.total');

                    const { edges, activeNodes } = this.getFilteredEdgesAndNodes();
                    this.visibleEdgeCount = edges.length;

                    const { rows, seqWidths, seqXStarts } = this.buildLayout(activeNodes);
                    const tokens = this.promptData.tokens;

                    const totalSeqWidth = seqXStarts[seqXStarts.length - 1] + seqWidths[seqWidths.length - 1];
                    this.graphWidth = totalSeqWidth + MARGIN.right;
                    this.graphHeight = Math.max(...Object.values(this.layerYPositions), 0) + COMPONENT_SIZE + MARGIN.bottom;

                    // Prepare nodes for renderer
                    const nodes = new Map();
                    for (const [key, pos] of Object.entries(this.nodePositions)) {
                        const [layer, seqIdx, cIdx] = key.split(':');
                        const importance = this.componentImportanceLocal[key] || 0;
                        const intensity = Math.min(1, importance / this.maxImportanceLocal);

                        let color, opacity;
                        if (layer === 'output') {
                            const probEntry = this.promptData.outputProbs[`${seqIdx}:${cIdx}`];
                            const prob = probEntry?.prob || 0;
                            const saturation = 20 + prob * 60;
                            const lightness = 70 - prob * 35;
                            color = `hsl(120, ${saturation}%, ${lightness}%)`;
                            opacity = 0.4 + prob * 0.6;
                        } else {
                            color = NODE_COLOR;
                            opacity = 0.2 + intensity * 0.8;
                        }

                        nodes.set(key, {
                            x: pos.x,
                            y: pos.y,
                            layer,
                            seqIdx: parseInt(seqIdx),
                            cIdx: parseInt(cIdx),
                            color,
                            opacity
                        });
                    }

                    // Prepare edges for renderer
                    const rendererEdges = [];
                    for (const e of edges) {
                        const p1 = this.nodePositions[e.srcKey];
                        const p2 = this.nodePositions[e.tgtKey];
                        if (p1 && p2) {
                            rendererEdges.push({
                                srcKey: e.srcKey,
                                tgtKey: e.tgtKey,
                                val: e.val,
                                x1: p1.x,
                                y1: p1.y,
                                x2: p2.x,
                                y2: p2.y,
                                color: e.val > 0 ? '#2196f3' : '#f44336',
                                opacity: this.linearInterpolate(0.1, 0.8, Math.abs(e.val) / this.maxAbsAttr)
                            });
                        }
                    }

                    // Set canvas size
                    const wrapper = this.$refs.canvasWrapper;
                    const canvas = this.$refs.graphCanvas;
                    if (wrapper && canvas) {
                        canvas.style.width = this.graphWidth + 'px';
                        canvas.style.height = this.graphHeight + 'px';
                    }

                    // Update renderer
                    this.renderer.setData({
                        nodes,
                        edges: rendererEdges,
                        seqLabels: [],
                        layerLabels: []
                    });

                    // Update highlights
                    this.updateHighlights();

                    // Render token labels (HTML for crisp text)
                    let tokenHtml = `<svg width="${this.graphWidth}" height="50" style="display:block;">`;
                    for (let i = 0; i < tokens.length; i++) {
                        const colCenter = seqXStarts[i] + seqWidths[i] / 2;
                        tokenHtml += `<text x="${colCenter}" y="20" text-anchor="middle" font-size="12" font-family="monospace" font-weight="500">${this.escapeHtml(tokens[i])}</text>`;
                        tokenHtml += `<text x="${colCenter}" y="38" text-anchor="middle" font-size="10" fill="#999">[${i}]</text>`;
                    }
                    tokenHtml += '</svg>';
                    this.$refs.tokenLabels.innerHTML = tokenHtml;

                    // Render layer labels (HTML for crisp text)
                    const rowYSet = new Map();
                    for (const layer in this.layerYPositions) {
                        const y = this.layerYPositions[layer];
                        if (!rowYSet.has(y)) rowYSet.set(y, this.getRowKey(layer));
                    }

                    let layerHtml = `<svg width="${LABEL_WIDTH}" height="${this.graphHeight}" style="display:block;">`;
                    for (const [y, rowKey] of rowYSet) {
                        const yCenter = y + COMPONENT_SIZE / 2;
                        let label;
                        if (rowKey.endsWith('.qkv')) {
                            label = `${rowKey.split('.')[1]}.q/k/v`;
                        } else if (rowKey === 'wte' || rowKey === 'output') {
                            label = rowKey;
                        } else {
                            const m = rowKey.match(/h\.(\d+)\.(attn|mlp)\.(\w+)/);
                            if (m) label = `${m[1]}.${m[3]}`;
                            else label = rowKey;
                        }
                        layerHtml += `<text x="${LABEL_WIDTH - 10}" y="${yCenter}" text-anchor="end" dominant-baseline="middle" font-size="11" font-weight="500" fill="${NODE_COLOR}">${label}</text>`;
                    }
                    layerHtml += '</svg>';
                    this.$refs.layerLabels.innerHTML = layerHtml;

                    timeEnd('render.total');
                },

                updateHighlights() {
                    if (!this.renderer) return;

                    const highlightedKeys = new Set();

                    // From pinned nodes - highlight all seq positions for same layer:cIdx
                    for (const pinned of this.pinnedNodes) {
                        for (const [key] of this.renderer.nodes) {
                            const [layer, , cIdx] = key.split(':');
                            if (layer === pinned.layer && parseInt(cIdx) === pinned.cIdx) {
                                highlightedKeys.add(key);
                            }
                        }
                    }

                    // From hovered node (if not pinned)
                    if (this.hoveredNode && !this.isNodePinned(this.hoveredNode.layer, this.hoveredNode.cIdx)) {
                        for (const [key] of this.renderer.nodes) {
                            const [layer, , cIdx] = key.split(':');
                            if (layer === this.hoveredNode.layer && parseInt(cIdx) === this.hoveredNode.cIdx) {
                                highlightedKeys.add(key);
                            }
                        }
                    }

                    this.renderer.setHighlightedNodes(highlightedKeys);
                },

                calcTooltipPos(mouseX, mouseY) {
                    const padding = 15;
                    let left = mouseX + padding;
                    let top = mouseY + padding;
                    if (left + 500 > window.innerWidth) left = mouseX - 500 - padding;
                    if (top + 400 > window.innerHeight) top = mouseY - 400 - padding;
                    return { x: Math.max(0, left), y: Math.max(0, top) };
                },

                maybeHideTooltip() {
                    setTimeout(() => {
                        if (!this.isHoveringTooltip) {
                            this.hoveredNode = null;
                            this.updateHighlights();
                        }
                    }, 100);
                },

                togglePin(layer, cIdx) {
                    const idx = this.pinnedNodes.findIndex(p => p.layer === layer && p.cIdx === cIdx);
                    if (idx >= 0) {
                        this.pinnedNodes.splice(idx, 1);
                    } else {
                        this.pinnedNodes.push({ layer, cIdx });
                        if (!this.activationContextsSummary) this.loadActivationContexts();
                    }
                    this.hoveredNode = null;
                    this.updateHighlights();
                },

                unpinNode(layer, cIdx) {
                    const idx = this.pinnedNodes.findIndex(p => p.layer === layer && p.cIdx === cIdx);
                    if (idx >= 0) this.pinnedNodes.splice(idx, 1);
                    this.updateHighlights();
                },

                isNodePinned(layer, cIdx) {
                    return this.pinnedNodes.some(p => p.layer === layer && p.cIdx === cIdx);
                },

                async searchPrompts() {
                    if (this.pinnedNodes.length === 0) return;

                    this.searchLoading = true;
                    this.searchError = null;

                    try {
                        const components = this.pinnedNodes.map(p => `${p.layer}:${p.cIdx}`).join(',');
                        const response = await fetch(`${this.apiBase}/api/search?components=${encodeURIComponent(components)}&mode=all`);
                        if (!response.ok) throw new Error(`Server error: ${response.status}`);
                        const result = await response.json();
                        if (result.error) throw new Error(result.error);
                        this.searchResults = result.results;
                    } catch (e) {
                        console.error('Error searching prompts:', e);
                        this.searchError = `Search failed: ${e.message}`;
                        this.searchResults = [];
                    } finally {
                        this.searchLoading = false;
                    }
                },

                buildLocalSectionHtml(layer, seqIdx, cIdx) {
                    let countEdges = 0;
                    for (const edge of this.allEdges) {
                        const [srcLayer, srcSeq, srcCIdx] = edge.srcKey.split(':');
                        const [tgtLayer, tgtSeq, tgtCIdx] = edge.tgtKey.split(':');
                        if ((srcLayer === layer && +srcSeq === seqIdx && +srcCIdx === cIdx) ||
                            (tgtLayer === layer && +tgtSeq === seqIdx && +tgtCIdx === cIdx)) {
                            countEdges++;
                        }
                    }
                    const importance = this.componentImportanceLocal[`${layer}:${seqIdx}:${cIdx}`] || 0;

                    return `<div class="node-local-section">
                        <h4>Node @ Position ${seqIdx}</h4>
                        <div><strong>Edges:</strong> ${countEdges} | <strong>Importance:</strong> ${importance.toFixed(4)}</div>
                    </div>`;
                },

                buildComponentHtml(layer, seqIdx, cIdx) {
                    let countEdges = 0;
                    for (const edge of this.allEdges) {
                        const [srcLayer, srcSeq, srcCIdx] = edge.srcKey.split(':');
                        const [tgtLayer, tgtSeq, tgtCIdx] = edge.tgtKey.split(':');
                        if ((srcLayer === layer && +srcSeq === seqIdx && +srcCIdx === cIdx) ||
                            (tgtLayer === layer && +tgtSeq === seqIdx && +tgtCIdx === cIdx)) {
                            countEdges++;
                        }
                    }

                    if (layer === 'output') {
                        const tokensAtPos = [];
                        for (const [probKey, entry] of Object.entries(this.promptData.outputProbs)) {
                            const [s, tokenId] = probKey.split(':');
                            if (+s === seqIdx) {
                                tokensAtPos.push({ tokenId: +tokenId, prob: entry.prob, token: entry.token });
                            }
                        }
                        tokensAtPos.sort((a, b) => b.prob - a.prob);

                        const hoveredEntry = tokensAtPos.find(t => t.tokenId === cIdx);
                        if (!hoveredEntry) return '<p>Token not found</p>';

                        const probPercent = (hoveredEntry.prob * 100).toFixed(1);
                        const headerBg = `linear-gradient(90deg, rgba(76, 175, 80, ${Math.min(0.8, hoveredEntry.prob + 0.1)}) 0%, rgba(76, 175, 80, 0.1) 100%)`;

                        let html = `<div style="background: ${headerBg}; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px;">
                            <div style="font-size: 1.4em; font-weight: bold;">"${this.escapeHtml(hoveredEntry.token)}"</div>
                            <div style="font-size: 1.1em; color: #333;">${probPercent}% probability</div>
                        </div>`;
                        html += `<p class="stats"><strong>Position:</strong> ${seqIdx} | <strong>Vocab ID:</strong> ${cIdx} | <strong>Edges:</strong> ${countEdges}</p>`;
                        html += `<h4>All Tokens at Position ${seqIdx}</h4>`;
                        html += `<table class="pr-table"><tr><th>Token</th><th>Prob</th></tr>`;
                        for (const t of tokensAtPos) {
                            const isHovered = t.tokenId === cIdx;
                            const rowStyle = isHovered ? 'background: rgba(76, 175, 80, 0.3); font-weight: bold;' : '';
                            html += `<tr style="${rowStyle}"><td><code>${this.escapeHtml(t.token)}</code></td><td>${(t.prob * 100).toFixed(2)}%</td></tr>`;
                        }
                        html += `</table>`;
                        return html;
                    }

                    const summary = this.activationContextsSummary?.[layer]?.find(s => s.subcomponent_idx === cIdx);
                    const detail = this.getComponentDetail(layer, cIdx);
                    const isLoading = this.componentDetailsLoading[`${layer}:${cIdx}`];

                    if (!summary && !detail) return `<p style="color: #666;">No activation context data</p>`;

                    let html = `<div class="component-section">`;
                    const meanCi = detail?.mean_ci ?? summary?.mean_ci;
                    if (meanCi !== undefined) html += `<p class="stats"><strong>Mean CI:</strong> ${meanCi.toFixed(4)}</p>`;

                    if (detail) {
                        if (detail.example_tokens?.length > 0) {
                            html += '<h4>Top Activating Examples</h4>';
                            for (let i = 0; i < Math.min(MAX_EXAMPLES_DISPLAY, detail.example_tokens.length); i++) {
                                const tokens = detail.example_tokens[i];
                                const ciVals = detail.example_ci[i];
                                const activePos = detail.example_active_pos[i];
                                html += `<div class="example-row">`;
                                for (let j = 0; j < tokens.length; j++) {
                                    const ci = ciVals[j];
                                    const isActive = j === activePos;
                                    const bg = `rgba(255, 100, 100, ${Math.min(1, ci * 5)})`;
                                    html += `<span class="example-token${isActive ? ' active' : ''}" style="background:${bg}">${this.escapeHtml(tokens[j])}</span>`;
                                }
                                html += `</div>`;
                            }
                        }

                        html += '<div class="tables-row">';
                        if (detail.pr_tokens?.length > 0) {
                            const prIndices = detail.pr_precisions.map((p, i) => [p, i]).sort((a, b) => b[0] - a[0]).map(x => x[1]);
                            html += '<div><h4>Top Input Tokens</h4><table class="pr-table"><tr><th>Token</th><th>P(fire|tok)</th></tr>';
                            for (let j = 0; j < Math.min(MAX_TOP_TOKENS_DISPLAY, prIndices.length); j++) {
                                const i = prIndices[j];
                                html += `<tr><td><code>${this.escapeHtml(detail.pr_tokens[i])}</code></td><td>${detail.pr_precisions[i].toFixed(3)}</td></tr>`;
                            }
                            html += '</table></div>';
                        }
                        if (detail.predicted_tokens?.length > 0) {
                            html += '<div><h4>Top Predicted</h4><table class="pr-table"><tr><th>Token</th><th>P</th></tr>';
                            for (let i = 0; i < Math.min(MAX_PREDICTED_TOKENS_DISPLAY, detail.predicted_tokens.length); i++) {
                                html += `<tr><td><code>${this.escapeHtml(detail.predicted_tokens[i])}</code></td><td>${detail.predicted_probs[i].toFixed(3)}</td></tr>`;
                            }
                            html += '</table></div>';
                        }
                        html += '</div>';
                    } else if (isLoading) {
                        html += '<p class="loading-text"><span class="loading-spinner"></span> Loading examples...</p>';
                    }

                    html += '</div>';
                    return html;
                },

                buildComponentHtmlNoSeq(layer, cIdx) {
                    let countEdges = 0;
                    for (const edge of this.allEdges) {
                        const [srcLayer, , srcCIdx] = edge.srcKey.split(':');
                        const [tgtLayer, , tgtCIdx] = edge.tgtKey.split(':');
                        if ((srcLayer === layer && +srcCIdx === cIdx) || (tgtLayer === layer && +tgtCIdx === cIdx)) {
                            countEdges++;
                        }
                    }

                    if (layer === 'output') {
                        const positions = [];
                        for (const [probKey, entry] of Object.entries(this.promptData.outputProbs)) {
                            const [seqIdx, tokenId] = probKey.split(':');
                            if (+tokenId === cIdx) {
                                positions.push({ seqIdx: +seqIdx, prob: entry.prob, token: entry.token });
                            }
                        }
                        if (positions.length === 0) return '<p>Token not found</p>';
                        positions.sort((a, b) => b.prob - a.prob);
                        const entry = positions[0];

                        let html = `<p><strong style="font-size: 1.2em;">"${this.escapeHtml(entry.token)}"</strong></p>`;
                        html += `<p class="stats"><strong>Vocab ID:</strong> ${cIdx} | <strong>Edges:</strong> ${countEdges}</p>`;
                        html += `<h4>Probability by Position</h4>`;
                        html += `<table class="pr-table"><tr><th>Pos</th><th>Prob</th></tr>`;
                        for (const pos of positions) {
                            html += `<tr><td>${pos.seqIdx}</td><td>${(pos.prob * 100).toFixed(2)}%</td></tr>`;
                        }
                        html += `</table>`;
                        return html;
                    }

                    const summary = this.activationContextsSummary?.[layer]?.find(s => s.subcomponent_idx === cIdx);
                    const detail = this.getComponentDetail(layer, cIdx);
                    const isLoading = this.componentDetailsLoading[`${layer}:${cIdx}`];

                    if (!summary && !detail) {
                        return `<p class="stats"><strong>Edges:</strong> ${countEdges}</p><p style="color: #666;">No activation context data</p>`;
                    }

                    const meanCi = detail?.mean_ci ?? summary?.mean_ci;
                    let html = `<p class="stats"><strong>Mean CI:</strong> ${meanCi?.toFixed(4) ?? '?'} | <strong>Edges:</strong> ${countEdges}</p>`;

                    if (detail) {
                        if (detail.example_tokens?.length > 0) {
                            html += '<h4>Top Activating Examples</h4>';
                            for (let i = 0; i < Math.min(MAX_EXAMPLES_DISPLAY, detail.example_tokens.length); i++) {
                                const tokens = detail.example_tokens[i];
                                const ciVals = detail.example_ci[i];
                                const activePos = detail.example_active_pos[i];
                                html += `<div class="example-row">`;
                                for (let j = 0; j < tokens.length; j++) {
                                    const ci = ciVals[j];
                                    const isActive = j === activePos;
                                    const bg = `rgba(255, 100, 100, ${Math.min(1, ci * 5)})`;
                                    html += `<span class="example-token${isActive ? ' active' : ''}" style="background:${bg}">${this.escapeHtml(tokens[j])}</span>`;
                                }
                                html += `</div>`;
                            }
                        }

                        html += '<div class="tables-row">';
                        if (detail.pr_tokens?.length > 0) {
                            const prIndices = detail.pr_precisions.map((p, i) => [p, i]).sort((a, b) => b[0] - a[0]).map(x => x[1]);
                            html += '<div><h4>Top Input Tokens</h4><table class="pr-table"><tr><th>Token</th><th>P(fire|tok)</th></tr>';
                            for (let j = 0; j < Math.min(MAX_TOP_TOKENS_DISPLAY, prIndices.length); j++) {
                                const i = prIndices[j];
                                html += `<tr><td><code>${this.escapeHtml(detail.pr_tokens[i])}</code></td><td>${detail.pr_precisions[i].toFixed(3)}</td></tr>`;
                            }
                            html += '</table></div>';
                        }
                        if (detail.predicted_tokens?.length > 0) {
                            html += '<div><h4>Top Predicted</h4><table class="pr-table"><tr><th>Token</th><th>P</th></tr>';
                            for (let i = 0; i < Math.min(MAX_PREDICTED_TOKENS_DISPLAY, detail.predicted_tokens.length); i++) {
                                html += `<tr><td><code>${this.escapeHtml(detail.predicted_tokens[i])}</code></td><td>${detail.predicted_probs[i].toFixed(3)}</td></tr>`;
                            }
                            html += '</table></div>';
                        }
                        html += '</div>';
                    } else if (isLoading) {
                        html += '<p class="loading-text"><span class="loading-spinner"></span> Loading examples...</p>';
                    }

                    return html;
                },

                escapeHtml(text) {
                    escapeDiv.textContent = text;
                    return escapeDiv.innerHTML;
                }
            };
        }
    </script>
</body>
</html>
